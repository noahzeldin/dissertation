---
title: "Measures Taken Formal Musical Analysis"
author: "Noah Zeldin"
date: "4/26/2021"
output: 
  github_document:
    toc: true
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
knitr::opts_knit$set(root.dir = "C:/Users/Noah Zeldin/Desktop/Proposal/R materials for dissertation/data/Massnahme_data")
```

# Introductory Remarks

Below is the annotated set-up for my formal analysis of Hanns Eisler's music to
*The Measures Taken*, which is included in the second chapter of my 
dissertation. This analysis was conducted in R. (I have tried to use 
[tidyverse](https://www.tidyverse.org/) syntax as consistently as possible. I
therefore refer to tables as ["tibbles"](https://tibble.tidyverse.org/).) 
Data sets will be made available to researchers upon request.

**NB: Further refinements to the coding are forthcoming.** 

# Load packages  

```{r}
library(tidyverse)
library(readxl)
library(ggforce)
library(scales)
library(lubridate)
library(mosaic) # may be unnecessary
```

# Importation 

There are **two** separate spreadsheets:

1. **durations** of each piece

2. data relating to the **choral** material

Both are necessary. The chapter begins with a structural overview of the 
work but focuses on the choral material. The calculations involved with the 
latter require the former.

## Duration

Import all sheets into a single list and specify column types:  

```{r}
durations_sheets <- excel_sheets("Massnahme_durations_meter_changes.xlsx")

durations_list <- lapply(durations_sheets, 
                         function(x) 
                             read_excel("Massnahme_durations_meter_changes.xlsx", 
                                                  sheet = x, 
                                                          col_types = c(
                                                              "text", # piece_no
                                                              "numeric", # category
                                                              "text", # subcategory
                                                              "numeric", # segment
                                                              "numeric", # m_start
                                                              "numeric", # m_end
                                                              "numeric", # no_of_mm
                                                              "numeric", # meter_1
                                                              "numeric", # meter_2
                                                              "numeric", # meter_ch_count
                                                              "numeric", # quarters_per_bar
                                                              "numeric", # beats
                                                              "numeric", # tempo
                                                              "numeric", # tempo_ch_count
                                                              "numeric") # duration
                                                          ))
```

From `durations_list` create single data frame and save as tibble:

```{r}
dur_tib <- as_tibble(bind_rows(durations_list))
```

## Voice Analysis

Check worksheets and ensure that there is a sheet for each piece containing 
choral material:

```{r}
excel_sheets("Massnahme_choir_voice_analysis.xlsx")
```

Import all sheets into a single list and specify column types:

```{r}
voice_analysis_sheets <- excel_sheets("Massnahme_choir_voice_analysis.xlsx")

voice_analysis_list <- lapply(voice_analysis_sheets, 
                           function(x) read_excel("Massnahme_choir_voice_analysis.xlsx", 
                                                  sheet = x, 
                                                          col_types = c(
                                                              "text", # piece_no
                                                              "numeric", # measure
                                                              "text", # texture
                                                              "numeric", # voices
                                                              "text", # groupings
                                                              
                                                              "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", # soprano:ratio
                                                              
                                                              "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", # rests
                                                              
                                                              "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", # quarters
                                                              
                                                              "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", # notes
                                                              
                                                              "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "text", "numeric", # tones
                                                              
                                                              "numeric", "numeric", # spoken, acapella
                                                              
                                                              "numeric", "numeric", "numeric", "numeric", # meter etc.
                                                              
                                                              "numeric", "numeric", "numeric", "numeric", # general dur's
                                                              
                                                              "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric" # dur's of voices
                                                              ) 
                                                              ))
```


From `voice_analysis_list` create single data frame and save as tibble:

```{r}
gen_tib <- as_tibble(bind_rows(voice_analysis_list))
```



# Cleaning and Manipulation: 1. Durations

Convert **piece_no**, **category** and **subcategory** to factors:

```{r}
dur_tib <- dur_tib %>% 
    mutate(piece_no = as_factor(piece_no)) %>% 
    mutate(category = as_factor(category)) %>% 
    mutate(subcategory = as_factor(subcategory))
```

<!-- Check to see if each piece is now a factor. -->

<!-- * NB: n col. refers to # of segments -->

<!-- ```{r} -->
<!-- dur_tib$piece_no %>%  -->
<!--     fct_count() -->
<!-- ``` -->

<!-- same for category -->

<!-- ```{r} -->
<!-- dur_tib$category %>%  -->
<!--     fct_count() -->
<!-- ``` -->


Re-level subcategories:

```{r}
dur_tib$subcategory <- dur_tib$subcategory %>% 
    fct_relevel("1b", after = 1) %>% 
    fct_relevel("2b", after = 2) %>% 
    fct_relevel("3b", after = 4) %>% 
    fct_relevel("3c", after = 5)

dur_tib$subcategory %>% 
    fct_count()
```


# Cleaning and Manipulation: 2. Voice Analysis

## General Tibble: gen_tib

Convert **piece_no** to factor:

```{r}
gen_tib <- gen_tib %>% 
    mutate(piece_no = as_factor(piece_no))
```

<!-- Check to see if each piece is now a factor. -->
<!-- * **Add something about n = # of mm. - and check.** -->

<!-- ```{r} -->
<!-- gen_tib$piece_no %>%  -->
<!--     fct_count() -->
<!-- ``` -->

Since 6c now follows 7a, must re-level (and check):

```{r}
gen_tib$piece_no <- gen_tib$piece_no %>% 
    fct_relevel("6c", after = 7)

gen_tib$piece_no %>% 
    fct_count()
```

Group by piece:

```{r}
by_piece <- gen_tib %>% group_by(piece_no)
```

Add **rowid** column and as new first column ("id"):

```{r}
gen_tib <- gen_tib %>% 
    rowid_to_column("id")
```


### Additional Calculations for Density

**NB: This section will in all likelihood be deleted, since it ultimately was 
not included in the final analysis.** The goal was to find a formula that would
allow for a quantitative comparison of the informational density of the choral
material in each measure.

Translate texture to numeric value in new column:

* monophony = 1

* homophony = 1.5

* antiphony = 1.5

* polyphony = 2

```{r}
gen_tib <- gen_tib %>% 
    mutate(texture_value = case_when(texture == "na" ~ "0", 
                                   texture == "m" ~ "1", 
                                   texture == "h" ~ "1.5", 
                                   texture == "a" ~ "1.5", # added 12.26.20
                                   texture == "p" ~ "2",)) %>% 
    mutate(texture_value = as.numeric(texture_value)) %>% 
    relocate(texture_value, .after = texture)
```

Add density column for each voice:

```{r}
gen_tib <- gen_tib %>% 
    mutate(dm_s1 = (notes_s1+tones_s1)/quarters_per_bar,
                      dm_s2 = (notes_s2+tones_s2)/quarters_per_bar,
                      dm_a1 = (notes_a1+tones_a1)/quarters_per_bar,
                      dm_a2 = (notes_a2+tones_a2)/quarters_per_bar,
                      dm_t1 = (notes_t1+tones_t1)/quarters_per_bar,
                      dm_t2 = (notes_t2+tones_t2)/quarters_per_bar,
                      dm_b1 = (notes_b1+tones_b1)/quarters_per_bar,
                      dm_b2 = (notes_b2+tones_b2)/quarters_per_bar)
```

Create a **dm_sum** column from 8 individual **dm** columns:

```{r}
gen_tib <- gen_tib %>% 
    rowwise() %>% 
    mutate(dm_sum = sum(c_across(dm_s1:dm_b2)))
```

With new **dm_sum** column, create **dmc** column:

```{r}
gen_tib <- gen_tib %>% 
    rowwise() %>% 
    mutate(dmc = (dm_sum/4)*texture_value)
```

Reconvert gen_tib to tibble after performing `rowwise()`:

```{r}
gen_tib <- gen_tib %>% as_tibble()
```


## Tibble for Choral Portions: gen_tib_sung

Filter out parts without choral singing (includes passages *spoken* by choir):

```{r}
gen_tib_sung <- gen_tib %>% 
    filter(texture != "na" & 
               parts_active > 0 & 
               spoken == 0) 
```

<!-- Check to see if any NAs remain. The following should return an **empty**  -->
<!-- table. -->

<!-- ```{r} -->
<!-- gen_tib_sung %>%  -->
<!--     filter(is.na(dm_s1), -->
<!--            is.na(dm_s2),  -->
<!--            is.na(dm_a1), -->
<!--            is.na(dm_a2), -->
<!--            is.na(dm_t1), -->
<!--            is.na(dm_t2), -->
<!--            is.na(dm_b1), -->
<!--            is.na(dm_b2)) %>%  -->
<!--     select(id, piece_no, measure, starts_with("notes_"), starts_with("tones_"), -->
<!--            quarters_per_bar, starts_with("dm_"))  -->
<!-- ``` -->


## Tibble for Pitch: pitch_tib

Create tibble containing data on choir's pitch material in each measure:

```{r}
pitch_tib <- gen_tib_sung %>% 
    select(id, piece_no, measure, tones, dur_choir, dmc) %>%
    relocate(tones, .after = dmc) %>% 
    mutate(
        c = str_count(tones, "c$|c\\,"),
        c_sharp_d_flat = str_count(tones, "c-sharp|d-flat"),
        d = str_count(tones, "d$|d\\,"),
        d_sharp_e_flat = str_count(tones, "d-sharp|e-flat"),
        e = str_count(tones, "e$|e\\,"),
        f = str_count(tones, "f$|f\\,"),
        f_sharp_g_flat = str_count(tones, "f-sharp|g-flat"),
        g = str_count(tones, "g$|g\\,"),
        g_sharp_a_flat = str_count(tones, "g-sharp|a-flat"),
        a = str_count(tones, "a$|a\\,"),
        a_sharp_b_flat = str_count(tones, "a-sharp|b-flat"),
        b = str_count(tones, "b$|b\\,"),    
                ) %>% 
    rowwise %>% 
    mutate(tones_sum = sum(c_across(c:b))) 
```


# Stats

This section contains calculations derived from the tibbles generated and 
cleaned in the previous sections. These calculations formed the basis of my
formal analysis and some of the values were used in the write-up included in
the chapter.

## Durations: General

### Total Duration in Minutes

```{r}
dur_total_min <- sum(dur_tib$duration) / 60
```

Total duration in minutes: `r round(dur_total_min, digits = 2)`.

### Duration by Piece

Create tibble with durations for all pieces:

```{r}
dur_piece <- dur_tib %>% 
    group_by(piece_no) %>%
    summarize(duration_min = (sum(duration) / 60)) %>% 
    mutate(prop_of_dur = (duration_min/sum(duration_min)),
           duration_min = round(duration_min, digits = 2),
           prop_of_dur = round(prop_of_dur, digits = 3))

knitr::kable(dur_piece)
```


Resort to find longest pieces:

```{r}
dur_piece %>% 
    arrange(desc(duration_min))
```

<!-- ##### NEW with Lubridate - FIX! -->

<!-- ```{r} -->
<!-- dur_piece_lubridate <- dur_piece %>%  -->
<!--     separate(duration_min, sep = "\\.", into = c("min", "sec")) %>%  -->
<!--     mutate(min = as.numeric(min), -->
<!--            sec = as.numeric(sec) # PROBLEM - removes zeros -->
<!--            ) %>%  -->
<!--     mutate(sec = round(sec * .6)) %>%  -->
<!--     mutate(duration = (minutes(min) + seconds(sec)), .keep = "unused") %>%  -->
<!--     relocate(duration, .after = piece_no) -->

<!-- dur_piece_lubridate -->
<!-- ``` -->


### Duration by Category

I assigned one of four categories to each of the pieces. These are:

1. choir with orchestra

2. spoken dialogue with orchestra

3. pieces featuring solo tenor

4. choir acapella or choir with snare drum


```{r}
dur_tib %>% 
    group_by(category) %>%
    summarize(duration = sum(duration)) %>% 
    mutate(prop_of_dur = (duration/sum(duration)))
```

<!-- No contest: two biggest categories are 1. choir with orchestra and 3. tenor solo -->
<!-- close to 95 % -->


### Duration by Subcategory

Each of the four categories was then subdivided, resulting in a total of ten
different subcategories of music. (All of this is laid out in **table 2.1. The 
Structure of *The Measures Taken*** in ch. 2 of the dissertation.)

```{r}
dur_subcategory <- dur_tib %>% 
    group_by(subcategory) %>%
    summarize(duration = sum(duration)) %>% 
    mutate(duration_min = (duration/60)) %>% 
    mutate(prop_of_dur = (duration/sum(duration)))

knitr::kable(dur_subcategory)
```


<!-- arranged descending -->

<!-- ```{r} -->
<!-- dur_subcategory %>%  -->
<!--     arrange(desc(prop_of_dur)) -->
<!-- ``` -->

<!-- Exactly what I expected:    -->
<!-- * largest proportion = 1a. mixed choir with orchestra -->
<!-- * followed by 3. tenor solo with accompaniment -->
<!-- * then 1b. = male choir with orchestra -->
<!-- ** actually, only one piece = Streiklied -->


## Meter and Tempo

An important feature of Eisler's music for *The Measures Taken* are the frequent
meter changes. These, along with the frequent tempo changes in a handful of 
pieces, demonstrate the necessity of a professional conductor. (The reliance
of the non-professional workers' choir on an array of professional musicians is 
an important part of my argument in the dissertation, as it contradicts much of
the previous, text-oriented scholarship on the work by Brecht scholars.) 

### Rates of Change

Construct tibble with following stats for each piece:

* duration

* number of meter changes

* rate of meter changes in seconds = duration / number of meter changes

* rate of meter changes in bars

* number of tempo changes

* rate of tempo changes in seconds = duration / number of meter changes

* rate of tempo changes in bars


```{r}
dur_meter_tempo_piece <- dur_tib %>% 
    group_by(piece_no) %>% 
    summarize(meter_ch_count = sum(meter_ch_count),
              tempo_ch_count = sum(tempo_ch_count),
              duration = sum(duration)) %>% 
    mutate(meter_ch_rate_sec = round(duration / meter_ch_count, 
                                     digits = 2),
           tempo_ch_rate_sec = round(duration / tempo_ch_count, 
                                     digits = 2),
           duration = round(duration, digits = 2)) %>% 
    relocate(meter_ch_rate_sec, .after = meter_ch_count) %>% 
    relocate(tempo_ch_rate_sec, .after = tempo_ch_count)

knitr::kable(dur_meter_tempo_piece)
```


<!-- sorted by **meter_ch_count**   -->

<!-- ```{r} -->
<!-- dur_meter_tempo_piece %>%  -->
<!--     arrange(desc(meter_ch_count)) %>%  -->
<!--     select(-tempo_ch_count, -tempo_ch_rate_sec) -->
<!-- ``` -->

5 pieces with greatest number of meter changes:

```{r}
meter_ch_count_piece_top_5 <- dur_meter_tempo_piece %>% 
    arrange(desc(meter_ch_count)) %>% 
    select(-tempo_ch_count, -tempo_ch_rate_sec) %>% 
    slice(1:5)

knitr::kable(meter_ch_count_piece_top_5)
```


<!-- sorted by **meter_ch_rate_sec** ASCENDING   -->

<!-- ```{r} -->
<!-- dur_meter_tempo_piece %>%  -->
<!--     filter(meter_ch_count != 1) %>%  -->
<!--     select(-tempo_ch_count, -tempo_ch_rate_sec) %>%  -->
<!--     arrange(meter_ch_rate_sec) -->
<!-- ``` -->

5 pieces with fastest rates of meter change:

```{r}
meter_ch_rate_piece_top_5 <- dur_meter_tempo_piece %>% 
    filter(meter_ch_count != 1) %>% 
    select(-tempo_ch_count, -tempo_ch_rate_sec) %>% 
    arrange(meter_ch_rate_sec) %>% 
    slice(1:5)

knitr::kable(meter_ch_rate_piece_top_5)
```

<!-- sorted by **tempo_ch_count**   -->

<!-- ```{r} -->
<!-- dur_meter_tempo_piece %>%   -->
<!--     select(-meter_ch_count, -meter_ch_rate_sec) %>%  -->
<!--     arrange(desc(tempo_ch_count)) -->
<!-- ``` -->

3 pieces with greatest number of tempo changes:  

```{r}
tempo_ch_count_and_rate_piece <- dur_meter_tempo_piece %>% 
    filter(tempo_ch_count != 1) %>% 
    select(-meter_ch_count, -meter_ch_rate_sec) %>% 
    arrange(tempo_ch_rate_sec)

knitr::kable(tempo_ch_count_and_rate_piece)
```

### Most Common Meters

Create tibble with meter, number of meters and duration:

```{r}
dur_meter <- dur_tib %>% 
    unite(meter_1, meter_2, col = "meter", sep = "_") %>% 
    select(piece_no, no_of_mm, meter, duration) %>% 
    relocate(meter, .after = piece_no) %>% 
    filter(meter != "0_0") # remove the pick-up from piece_no 10
```

Most common meters by number of measures:

```{r}
dur_meter %>% 
    group_by(meter) %>% 
    count(no_of_mm) %>% 
    mutate(no_of_mm = no_of_mm * n) %>% 
    select(-n) %>% 
    summarize(no_of_mm = sum(no_of_mm)) %>% 
    arrange(desc(no_of_mm))
```

Most common meters by duration:

```{r}
dur_meter %>% 
    group_by(meter) %>% 
    summarize(duration = sum(duration)) %>% 
    arrange(desc(duration))
```

#### Grouped by Duple vs. Triple

Exploring the proportion of duple vs. triple meters allows one to determine 
Eisler's engagement with march-like anthems (duple meters) and subversion 
thereof (triple meters). In short, while the music to *The Measures Taken* is
undoubtedly highly political, Eisler, in his typical manner, used musical 
materials in a critical fashion, rather than composing straightforward anthems.


```{r}
dur_meter_groups <- dur_meter %>% 
    group_by(meter) %>% 
    summarize(duration = sum(duration)) %>% 
    separate(meter, sep = "_", into = c("meter_1", "meter_2")) %>% 
    mutate(meter_1 = as.factor(meter_1))

dur_meter_groups$meter_1 <- dur_meter_groups$meter_1 %>% 
    fct_relabel(~ c("other", "duple", "triple", "duple", "duple"))

dur_meter_groups <- dur_meter_groups %>% 
    select(-meter_2) %>% 
    rename(group = meter_1) %>% 
    group_by(group) %>% 
    summarize(duration = sum(duration)) %>% 
    mutate(prop_dur = duration / sum(duration),
           perc_dur = round(prop_dur*100))

knitr::kable(dur_meter_groups)
```

<!-- Interesting: pretty evenly split. -->

#### Special Case: 6/4

6/4 is compound duple and therefore a special case. NB: 6/4 is the only compound
duple meter present in the work.

Check which measures are in 6/4:

```{r}
gen_tib %>% 
  filter(meter_1 == 6, meter_2 == 4) 
```

Compute percent of duration that is 6/4:

```{r}
dur_6_4_perc <- round((dur_meter %>% 
    filter(meter == "6_4") %>% 
    select(duration) %>% 
    sum() / 
  dur_meter_groups %>% 
    select(duration) %>% 
    sum()) * 100, digits = 1)
```

`r dur_6_4_perc` % of the work is in 6/4.

Compute percent of duration of duple that is 6/4:

```{r}
dur_6_4_duple_perc <- round((dur_meter %>% 
    filter(meter == "6_4") %>% 
    select(duration) %>% 
    sum() / 
  dur_meter_groups %>% 
    filter(group == "duple") %>% 
    select(duration) %>% 
    sum()) * 100, digits = 1)
```

`r dur_6_4_duple_perc` % of measures with duple meters are in 6/4.


<!-- ```{r} -->
<!-- # duration of duple meters -->
<!-- dur_meter_groups %>%  -->
<!--   filter(group == "duple") %>%  -->
<!--   select(duration) - -->
<!--   # subtract duration of 6/4 measures -->
<!--   dur_meter %>%  -->
<!--     filter(meter == "6_4") %>%  -->
<!--     select(duration) %>%  -->
<!--     sum() -  -->
<!--   # subtract duration of triple meters -->
<!--   dur_meter_groups %>%  -->
<!--   filter(group == "triple") %>%  -->
<!--   select(duration) -->
<!-- ``` -->

<!-- Almost even. -->


## Durations: Choir

This section is very significant to my analysis, which focuses on the choral
material. The calculations here determine the proportions of choral material 
that are sung (with and without instrumental accompaniment) or spoken.

### Choir Total Durations

Create tibble containing only measures with choir:

```{r}
choir_tib <- gen_tib %>% 
    filter(dur_choir != 0)
```

Total duration of choir:

```{r}
dur_choir_total_sec <- sum(choir_tib$dur_choir)
dur_choir_total_min <- sum(choir_tib$dur_choir) / 60
```

The choir is active for `r round(dur_choir_total_min, digits = 2)` minutes.

Duration of choir as proportion of total duration:

```{r}
dur_choir_prop <- round((dur_choir_total_min / dur_total_min), digits = 4)*100
print(dur_choir_prop)
```

The choir is active for `r dur_choir_prop` % of total duration of music.


### Choir Sung Durations

```{r}
gen_tib %>% 
    filter(dur_choir != 0 & spoken == 0) %>% 
    group_by(piece_no) %>% 
    select(piece_no, dur_choir) %>% 
    summarize(dur_choir = sum(dur_choir)) %>% 
    mutate(dur_choir_prop = dur_choir / sum(dur_choir)) %>% 
    mutate(dur_choir = round(dur_choir, digits = 2), 
           dur_choir_prop = round(dur_choir_prop, digits = 3)) %>% 
    arrange(desc(dur_choir_prop))
```

<!-- Pretty interesting: -->
<!-- * 9. Aendere die Welt has by far most choir singing -> include in analysis -->
<!-- * other pieces with complex polyphony in top 5: -->
<!-- ** 4. Lob der illegalen Arbeit and 2b. Lob der USSR -->

### Choir Acapella Durations

```{r}
dur_acapella <- gen_tib %>% 
    filter(acapella == 1) %>% 
    group_by(piece_no) %>% 
    select(piece_no, dur_choir) %>% 
    summarize(dur_choir = sum(dur_choir)) %>% 
    mutate(dur_choir_prop = dur_choir / sum(dur_choir),
           dur_choir = round(dur_choir, digits = 2),
           dur_choir_prop = round(dur_choir_prop, digits = 3)) 

knitr::kable(dur_acapella)
```

Arrange descending to see top pieces:

```{r}
dur_acapella %>% 
    arrange(desc(dur_choir_prop))
```

Proportion of `dur_chor` that is acapella:

```{r}
sum(dur_acapella$dur_choir) / dur_choir_total_sec
```



<!-- Good results: -->
<!-- * top 2 are 2b. Lob der USSR and 9. Aendere die Welt -->


### Choir Spoken Durations

```{r}
gen_tib %>% 
    filter(spoken == 1) %>% 
    group_by(piece_no) %>% 
    select(piece_no, dur_choir) %>% 
    summarize(dur_choir = sum(dur_choir)) %>% 
    mutate(dur_choir_prop = dur_choir / sum(dur_choir),
           dur_choir = round(dur_choir, digits = 2),
           dur_choir_prop = round(dur_choir_prop, digits = 3)) %>% 
    arrange(desc(dur_choir_prop))
```

<!-- Interesting that 14. Schlusschor is top. -->

<!-- Other remarks: -->
<!-- * close second is 3b. Sprechchor = Wer fuer den Kommunismus kaempft -->
<!-- * interesting that 3b. is only category 4 piece in top 5 -->

### Choir Voice Durations 

#### Check for measures where duration of 1st and 2nd parts don't align.

NB: As is typical for choral music, Eisler sometimes splits the part of one or 
more of the four voices. The calculations below take account of this.

1. Sopranos

```{r}
gen_tib_sung %>% 
    filter(quarters_s1 != 0 & quarters_s2 != 0 & quarters_s1 != quarters_s2)
```

2. Altos

```{r}
gen_tib_sung %>% 
    filter(quarters_a1 != 0 & quarters_a2 != 0 & quarters_a1 != quarters_a2)
```

3. Tenors

```{r}
gen_tib_sung %>% 
    filter(quarters_t1 != 0 & quarters_t2 != 0 & quarters_t1 != quarters_t2) 
```

Only antiphonic passage at beginning of "Lob der Partei." Doesn't matter, 
because t1 and t2 overlap.

4. Basses

```{r}
gen_tib_sung %>% 
    filter(quarters_b1 != 0 & quarters_b2 != 0 & quarters_b1 != quarters_b2)
```

Final measure of "Streiklied." Doesn't matter, because b1 and b2 overlap.


#### Check for measures where 2nd sings but 1st doesn't

NB: Similar goal as in previous section.


1. Sopranos

```{r}
gen_tib_sung %>% 
    filter(quarters_s1 == 0 & quarters_s2 != 0)
```

2. Altos

```{r}
gen_tib_sung %>% 
    filter(quarters_a1 == 0 & quarters_a2 != 0)
```

3. Tenors

```{r}
gen_tib_sung %>% 
    filter(quarters_t1 == 0 & quarters_t2 != 0)
```

Only beginning of "Lob der Partei," as expected.

Save as extra duration to add to male proportion.

```{r}
dur_t2_extra <- gen_tib_sung %>% 
  filter(quarters_t1 == 0 & quarters_t2 != 0) %>%
  select(dur_t2) %>% 
  sum()
```


4. Basses

```{r}
gen_tib_sung %>% 
    filter(quarters_b1 == 0 & quarters_b2 != 0)
```


##### Same but with duration

1. Sopranos

```{r}
gen_tib_sung %>% 
    filter(dur_s1 != 0 & dur_s2 != 0 & dur_s1 != dur_s2)
```

2. Altos

```{r}
gen_tib_sung %>% 
    filter(dur_a1 != 0 & dur_a2 != 0 & dur_a1 != dur_a2)
```

3. Tenors

```{r}
gen_tib_sung %>% 
    filter(dur_t1 != 0 & dur_t2 != 0 & dur_t1 != dur_t2) %>% 
    select(piece_no, measure, dur_t1, dur_t2) 
```

Again, doesn't matter because of overlap.

4. Basses

```{r}
gen_tib_sung %>% 
    filter(dur_b1 != 0 & dur_b2 != 0 & dur_b1 != dur_b2) %>% 
    select(piece_no, measure, dur_b1, dur_b2)
```

Again, doesn't matter because of overlap.



#### Computations for male vs. female

The introduction of mixed choirs into the German worker-singers' movement was a
widely discussed and highly politicized topic in the Weimar Republic. These 
calculations determine the extent to which Eisler used women's voices in 
comparison to men's voices.

<!-- Four voices - FIX - need to account for doublings, can't just add 1 and 2 -->

<!-- **CURRENTLY SKIPPING THIS CHUNK - PROB DELETE** -->
<!-- ```{r, eval=FALSE} -->
<!-- dur_soprano <- sum(gen_tib_sung$dur_s1 + gen_tib_sung$dur_s2) -->
<!-- dur_alto <- sum(gen_tib_sung$dur_a1 + gen_tib_sung$dur_a2) -->
<!-- dur_tenor <- sum(gen_tib_sung$dur_t1 + gen_tib_sung$dur_t2) -->
<!-- dur_bass <- sum(gen_tib_sung$dur_b1 + gen_tib_sung$dur_b2) # FIX/CHECK -->

<!-- dur_soprano <- sum(gen_tib_sung$soprano * gen_tib_sung) -->


<!-- dur_voice <-  -->
<!--     tibble(voice = c("soprano", "alto", "tenor", "bass"), -->
<!--     dur_min =  -->
<!--     c(dur_soprano /60,  -->
<!--     dur_alto / 60,  -->
<!--     dur_tenor / 60,  -->
<!--     dur_bass / 60)) -->

<!-- dur_voice %>%  -->
<!--     mutate(dur_prop = dur_min / sum(dur_min)) -->
<!-- ``` -->

Generate sums of sung material for each voice:

```{r}
dur_s1_sung <- gen_tib_sung %>% 
    select(dur_s1) %>% 
    sum()

dur_a1_sung <- gen_tib_sung %>% 
    select(dur_a1) %>% 
    sum()

dur_t1_sung <- gen_tib_sung %>% 
    select(dur_t1) %>% 
    sum()

dur_b1_sung <- gen_tib_sung %>% 
    select(dur_b1) %>% 
    sum()

dur_sung_total <- dur_s1_sung + dur_a1_sung + dur_t1_sung + dur_b1_sung + dur_t2_extra

dur_female_sung <- dur_s1_sung + dur_a1_sung
dur_male_sung <- dur_t1_sung + dur_b1_sung + dur_t2_extra
```

Calculate proportions of male and female durations:

```{r}
dur_female_sung_perc <- round((dur_female_sung/dur_sung_total)*100)
dur_male_sung_perc <- round((dur_male_sung/dur_sung_total)*100)
```


Compute proportion of discrepancy resulting from pieces 5 and 7a:

1. Get extra durations for tenors and basses:

```{r}
dur_t1_sung_5_and_7a <- gen_tib_sung %>% 
    filter(piece_no == "5" | piece_no == "7a") %>% 
    select(dur_t1) %>% 
    sum()

dur_b1_sung_5_and_7a <-gen_tib_sung %>% 
    filter(piece_no == "5" | piece_no == "7a") %>% 
    select(dur_b1) %>% 
    sum()
```

2. Amount by which dur_male is longer than dur_female:

```{r}
dur_male_sung - dur_female_sung
```

3. Extra duration from 5 and 7a:

```{r}
dur_t1_sung_5_and_7a + dur_b1_sung_5_and_7a
```

4. Compute percentage:

```{r}
dur_male_extra_from_5_and_7a_perc <- 
  round(((dur_t1_sung_5_and_7a + dur_b1_sung_5_and_7a) /
         (dur_male_sung - dur_female_sung)) * 100)

dur_male_extra_from_5_and_7a_perc
```


## Texture

The texture of the choral writing plays a pivotal role in my analysis. The 
calculations in this section confirm implicitly statistical observations made in
previous analyses of the work, most significantly the claim that homophony 
dominates.

Additionally, the results of the analysis here provide the foundation for my 
claim that there is a strong relationship between choral texture and textual
content. In short, Eisler tends to set texts with concrete political content to 
sparser choral textures (monophony and reduced homophony). This claim is fully
developed in ch. 2.


### Whole Work

#### By Measure Count

Generate tibble for whole work:

```{r}
texture_tib <- gen_tib %>% 
    count(texture) %>% 
    as_tibble %>% 
    rename(n_measures = n) %>% 
    filter(texture != "na") %>% 
    mutate(prop_of_sung = (n_measures/sum(n_measures)*100))
```

<!-- Check to see if proportions add up to 100, in order to ensure that order of  -->
<!-- previous step is correct. -->

<!-- ```{r} -->
<!-- sum(texture_tib$prop_of_sung) == 100  -->
<!-- ``` -->

Create a basic barplot of textures for whole work:

```{r}
texture_tib %>% 
    ggplot() +
    geom_col(aes(x = texture, y = prop_of_sung, fill = texture))
```

Homophony clearly dominates, followed by monophony.


#### By Duration

Create tibble:

```{r}
dur_texture_work <- gen_tib %>% 
    filter(texture != "na") %>% 
    group_by(texture) %>% 
    summarize(duration = dur_choir) %>% 
    summarize(duration = sum(duration)) %>% 
    mutate(prop_of_sung = round((duration/sum(duration)), 
                                digits = 2),
           perc_of_sung = prop_of_sung*100) 
```

Create barplot:

```{r}
dur_texture_work %>% 
    ggplot() +
    geom_col(aes(x = texture, y = prop_of_sung, fill = texture))
```

Again, homophony clearly dominates, followed by monophony.

<!-- #### Table of Polyphonic Passages by Piece/Measure -->

<!-- ```{r} -->
<!-- gen_tib_sung %>%  -->
<!--     filter(texture == "p") %>%  -->
<!--     select(id:texture)  -->
<!-- ``` -->


### Individual Pieces (By Duration)

<!-- #### By Measure Count -->

<!-- Generate basic tibble, grouped by piece: -->

<!-- ```{r} -->
<!-- texture_piece <- by_piece %>%  -->
<!--     count(texture) %>%  -->
<!--     as_tibble %>%  -->
<!--     rename(n_measures = n) %>%  -->
<!--     filter(texture != "na") %>% -->
<!--     group_by(piece_no) %>%  -->
<!--     mutate(mm_sung = sum(n_measures)) %>%  -->
<!--     mutate(prop_of_sung = (n_measures/sum(n_measures)*100))  -->
<!-- ``` -->

<!-- Relevel factors for piece_no, so that bars in barcharts below appear in correct order: -->

<!-- ```{r} -->
<!-- texture_piece <- texture_piece %>%  -->
<!--     mutate(piece_no = fct_relevel(piece_no,  -->
<!--                                   c("1", "2b", "4", "5", "6c", "7a", "8b",  -->
<!--                                     "9","10", "11", "12b","13a", "13b", "14"))) -->
<!-- ``` -->

<!-- Create a stacked bar chart displaying the proportions of each texture in each -->
<!-- piece. **MAY NEED TO CHANGE** `width = 0.3`. -->

<!-- ```{r} -->
<!-- bar_texture_piece <- texture_piece %>%  -->
<!--     ggplot(aes(fill = texture, y = prop_of_sung, x = piece_no)) + -->
<!--     geom_bar(position = "stack", stat = "identity",  -->
<!--              width = 0.45 # play with this -->
<!--              ) + -->
<!--     xlab("Piece Number") + -->
<!--     scale_fill_discrete(name = "Texture", -->
<!--                         labels = c("Antiphony", "Homophony",  -->
<!--                                    "Monophony", "Polyphony")) + -->
<!--     theme(axis.title.y = element_blank(), -->
<!--           axis.ticks.y = element_blank(), -->
<!--           axis.text.y = element_blank(), -->
<!--           axis.ticks.x = element_blank() -->
<!--          ) + -->
<!--     ggtitle("Proportion of Texture by Piece") -->

<!-- bar_texture_piece -->
<!-- ``` -->

Create tibble:

```{r}
dur_texture_piece <- gen_tib %>% 
    filter(texture != "na") %>% 
    group_by(piece_no, texture) %>% 
    summarize(duration = dur_choir) %>% 
    summarize(duration = sum(duration)) %>% 
    mutate(prop_of_piece = round((duration/sum(duration)), 
                                 digits = 2)) %>% 
    group_by(piece_no) %>% 
    mutate(dur_piece = sum(duration)
           ) %>% 
    relocate(dur_piece, .after = duration) %>% 
    ungroup() %>% 
    mutate(prop_of_work = round((duration / sum(duration)), 
                                digits = 3),
           prop_piece_of_work = dur_piece/sum(dur_piece)) # check if necessary
```

Create mosaic plot, displaying proportion of each texture in each piece:

```{r}
# create new table just for this plot
dur_texture_piece_mosaic_table <- gen_tib %>% 
    filter(texture != "na") %>% 
    group_by(piece_no, texture) %>% 
    summarize(duration = dur_choir) %>% 
    summarize(duration = sum(duration)) %>% 
    mutate(prop_of_piece = duration/sum(duration)) %>% 
    group_by(piece_no) %>% 
    mutate(dur_piece = sum(duration)) %>% 
    ungroup()

# eliminate 13a for readability
dur_texture_piece_mosaic_table <- dur_texture_piece_mosaic_table %>% 
    filter(piece_no != "13a")

# code for plot
dur_texture_piece_mosaic_plot <- ggplot(dur_texture_piece_mosaic_table, 
       aes(x = piece_no, y = prop_of_piece, 
           width = dur_piece, fill = texture)) +
    geom_bar(stat = "identity", position = "fill", color = "black") +
    facet_grid(~piece_no, scales = "free_x", space = "free_x") +
    scale_fill_brewer(palette = "RdYlGn") +
    xlab("Piece Number") +
    scale_fill_discrete(name = "Texture",
                        labels = c("Antiphony", "Homophony", 
                                   "Monophony", "Polyphony")) +
    scale_y_continuous(expand = c(0,0)) + 
    theme(axis.title.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.x = element_blank(),
          strip.background = element_blank(),
          strip.text.x = element_blank(),
          panel.border = element_rect(colour = "black", fill = NA),
          panel.background = element_rect(fill = NA, color = "white")
          ) +
    labs(title = "Proportion of Choral Texture by Piece",
         subtitle = "Bar width corresponds to duration of choral material in each piece. \n13a removed for readability.")

dur_texture_piece_mosaic_plot
```


<!-- #### Presence of Each Texture by Piece -->

<!-- Create table: -->

<!-- ```{r} -->
<!-- texture_piece_presence <- dur_texture_piece %>%  -->
<!--     group_by(piece_no, texture) %>%  -->
<!--     count(texture) %>%  -->
<!--     spread(texture, n, fill = 0) %>%  -->
<!--     mutate(no_of_textures = sum(c_across(a:p))) -->

<!-- texture_piece_presence -->
<!-- ``` -->

<!-- ##### Pieces grouped by number of textures -->

<!-- Pieces with 3 textures. -->

<!-- ```{r} -->
<!-- texture_piece_presence %>%  -->
<!--     filter(no_of_textures == 3) -->
<!-- ``` -->

<!-- Pieces with 1 texture. -->

<!-- ```{r} -->
<!-- texture_piece_presence %>%  -->
<!--     filter(no_of_textures == 1) -->
<!-- ``` -->

<!-- Really interesting - all homophonic. -->


<!-- ##### Grouped by type of texture -->

<!-- 1. with antiphony -->

<!-- ```{r} -->
<!-- texture_piece_presence %>%  -->
<!--     filter(a == 1) -->
<!-- ``` -->

<!-- Yep, only start of "Lob der Partei". -->

<!-- 2. with homophony -->

<!-- ```{r} -->
<!-- texture_piece_presence %>%  -->
<!--     filter(h == 1) -->
<!-- ``` -->

<!-- So, every single piece. -->

<!-- 3. with monophony -->

<!-- ```{r} -->
<!-- texture_piece_presence %>%  -->
<!--     filter(m == 1) -->
<!-- ``` -->

<!-- ###### CONSIDER CHANGING - MAY NOT NEED VALUE -->

<!-- 4. with polyphony -->

<!-- ```{r} -->
<!-- no_pieces_with_polyphony <- texture_piece_presence %>%  -->
<!--     filter(p == 1) %>%  -->
<!--     print() %>%  -->
<!--     nrow() -->
<!-- ``` -->


## Pitch

Although pitch is a secondary consideration in my analysis, I wanted to get a 
sense of the chromaticism of each piece. As I point out in ch. 2, the pieces
with more concretely political texts tend to be less chromatic.

### Set-Up for Pitch Computations

Create new, elongated table with pitches:

```{r}
pitch_long <- pitch_tib %>% 
    # this first step may be unnecessary if factors work
    mutate(c = c*1, # unnecessary but included for clarity
           c_sharp_d_flat = c_sharp_d_flat*2,
           d = d*3,
           d_sharp_e_flat = d_sharp_e_flat*4,
           e = e*5,
           f = f*6,
           f_sharp_g_flat = f_sharp_g_flat*7,
           g = g*8,
           g_sharp_a_flat = g_sharp_a_flat*9,
           a = a*10,
           a_sharp_b_flat = a_sharp_b_flat*11,
           b = b*12) %>% 
    pivot_longer(c:b, names_to = "pitch", values_to = "value") %>% 
    filter(value != 0) %>% 
    mutate(pitch = as.factor(pitch),
           value = as.factor(value)
           ) %>% 
    mutate(pitch = fct_relevel(pitch,
                             levels = c("c",
                                        "c_sharp_d_flat",
                                        "d",
                                        "d_sharp_e_flat",
                                        "e",
                                        "f",
                                        "f_sharp_g_flat",
                                        "g",
                                        "g_sharp_a_flat",
                                        "a",
                                        "a_sharp_b_flat",
                                        "b")))

# check if pitches are correctly factored
levels(pitch_long$pitch)
```

### Pitch Distribution

```{r}
pitch_distribution_plot <- pitch_long %>% 
    group_by(piece_no) %>% 
    mutate(prop_piece = dur_choir / sum(dur_choir)) %>% 
    select(piece_no, pitch, prop_piece) %>% 
    ggplot(aes(x = pitch,
                 fill = pitch, y = prop_piece)) +
    geom_col(
        # color = "black" # want to add outline to entire bar but this splits for each obs.
        ) +
    scale_x_discrete(labels = c("C ", "C#", "D ", "D#", "E ", "F ", "F#",
                                "G ", "G#", "A ", "A#", "B " )) +
    scale_y_continuous(
        breaks = c(0.25, 0.5), labels = c("25%", "50%") # gives same as automated in next line
        # labels = percent_format()
        ) +
    ylab("Proportion of Appearances of all Pitches per Number of Measures") + # FIX
    facet_wrap(~piece_no, ncol = 7) +
    coord_flip() +
    theme(legend.position = "none", 
          axis.title.y = element_blank(),
          panel.background = element_rect(fill = "white", colour = 'black'),
          panel.grid.major.y = element_line(color = "grey", linetype = 3),
          panel.grid.major.x = element_line(color = "grey", linetype = 3),
          strip.background = element_rect(fill = "gray89", 
                                          color = "black")) +
    labs(title = "Distribution of Choir's Pitches"
         # , subtitle = "Based on number of measures, in which each pitch appears."
         )

pitch_distribution_plot
```

<!-- **OLD** -->

<!-- ```{r, eval=FALSE} -->
<!-- # pitch_long %>%  -->
<!-- #     ggplot() + -->
<!-- #     geom_bar(aes(x = pitch, -->
<!-- #                  fill = pitch, -->
<!-- #                  y = ..count../sum(..count..))) + -->
<!-- #     scale_y_continuous(labels = percent_format()) + -->
<!-- #     scale_x_discrete(labels = c("C", "C#", "D", "D#", "E", "F", "F-sh", -->
<!-- #                                 "G", "G-sh", "A", "A-sh", "B")) + -->
<!-- #     facet_wrap(~piece_no, ncol = 5) + -->
<!-- #     coord_flip() + -->
<!-- #     theme(legend.position = "none",  -->
<!-- #           axis.title.x = element_blank(), -->
<!-- #           axis.title = element_blank(), -->
<!-- #           axis.text.x = element_blank(), -->
<!-- #           axis.ticks.x = element_blank(), -->
<!-- #           panel.background = element_rect(fill = "white", colour = 'black'), -->
<!-- #           panel.grid.major.y = element_line(color = "grey", linetype = 3), -->
<!-- #           strip.background = element_rect(fill = "gray89",  -->
<!-- #                                           color = "black")) + -->
<!-- #     labs(title = "Distribution of Choir's Pitches", -->
<!-- #          subtitle = "Based on number of measures, in which each pitch appears. \nBar length corresponds to proportion of whole.") -->
<!-- ``` -->


### Chromaticism of Each Piece

Sort pieces by number of pitches that appear in choral writing.

```{r}
pitch_no_piece <- pitch_long %>% 
    group_by(piece_no) %>% 
    count(pitch) %>% 
    count(piece_no) %>% 
    rename(no_of_pitches = n) %>% 
    arrange(desc(no_of_pitches))

pitch_no_piece
```


## Groupings 

<!-- UPDATE 12.08: changed source data from `gen_tib` to `gen_tib_sung`. -->
<!-- * This should avoid pieces with no singing. -->

Directly related to Eisler's heavy use of reduced choral textures (monophony
and homophony), the composer also frequently groups voices together. The 
calculations in this section explore this compositional tactical and e.g. 
determine which groupings of voices are most common.  

NB: It is necessary to perform two separate calculations:  

1. separate groupings  

2. combinations of groupings  

To give an example, the first reveals the duration of the grouping sopranos-
tenors, while the second will reveals the duration of this grouping *plus* the
grouping altos-basses. 

<!-- **2. combinations of groupings** will be much easier, because this is the  -->
<!-- existing observation in the spreadsheet. Can calculate now.   -->

<!-- Will need to put in some work for **1. separate groupings.**   -->

<!-- * must separate groupings, probably into different columns and then count   -->

### Combinations of Groupings   

#### By Number of Measures  

Generate basic tibble for whole work:

```{r}
groupings_tib <- gen_tib_sung %>% 
    count(groupings) %>% # number of measures but not durations
    as_tibble %>% 
    rename(n_groupings = n) %>% 
    filter(groupings != "na") %>% 
    mutate(prop_of_groupings = n_groupings/sum(n_groupings))
```



Create list of 5 most common groupings:

```{r}
groupings_5 <- groupings_tib %>% 
    arrange(desc(prop_of_groupings)) %>%
    select(groupings, prop_of_groupings) %>%
    slice(1:5) %>% 
    mutate(perc_of_groupings = round((prop_of_groupings*100), digits = 0)) %>% 
    print()
```


#### By Duration (of Measures)  

Create tibble with groupings, duration and proportion:  

```{r}
groupings_dur_tib <- gen_tib_sung %>% 
    select(groupings, duration) %>% 
    filter(groupings != "na") %>% 
    group_by(groupings) %>%
    summarize(duration = sum(duration)) %>% 
    mutate(prop_of_dur = (duration/sum(duration)))
```

Create list of 5 most common groupings by duration:

```{r}
groupings_5_dur <- groupings_dur_tib %>% 
    arrange(desc(prop_of_dur)) %>%
    select(groupings, prop_of_dur) %>%
    slice(1:5) %>%  
    mutate(perc_of_dur = round(prop_of_dur*100))

groupings_5_dur 
```

This differs only slightly from previous computation (by number of measures). 
Top 3 and no. 5 are same as `groupings_5` but 4th place is now **satb** (rather 
than st). 

##### Separated by Texture

```{r}
groupings_texture_dur <- gen_tib_sung %>% 
    select(groupings, texture, duration) %>% 
    filter(groupings != "na",
           texture != "na") %>% 
    group_by(groupings, texture) %>%
    summarize(duration = sum(duration)) %>% 
    mutate(prop_of_dur_text = (duration/sum(duration)),
           perc_of_dur_text = round(prop_of_dur_text*100)) %>%
    arrange(groupings, desc(duration))

groupings_texture_dur
```

With top 5 groupings:

```{r}
groupings_texture_dur_5 <- semi_join(groupings_texture_dur, groupings_5_dur)

groupings_texture_dur_5
```

Compute percentages of each texture:

```{r}
groupings_texture_dur_5 %>% 
    group_by(texture) %>% 
    summarize(duration = sum(duration)) %>% 
    mutate(prop_dur = duration / sum(duration),
           perc_dur = round(prop_dur * 100))
```

Just homophony:

```{r}
groupings_homophony_dur <- gen_tib_sung %>% 
    filter(texture == "h") %>% 
    select(groupings, duration) %>% 
    group_by(groupings) %>% 
    summarize(duration = sum(duration)) %>% 
    mutate(prop_of_dur = (duration/sum(duration)),
           perc_of_dur = round(prop_of_dur*100
                               # , digits = 1 # not sure how hard I can round,
                               # really only need top 3/4, so doesn't matter
                               )) %>% 
    arrange(desc(duration))

groupings_homophony_dur
```

Show that all instances of homophony with no groupings are just two voices 
(necessary for write-up in ch. 2):

```{r}
gen_tib_sung %>% 
    filter(texture == "h" & groupings == "none") %>% 
    select(voices, duration) %>% 
    group_by(voices) %>% 
    summarize(duration = sum(duration)) %>% 
    mutate(prop_of_dur = (duration/sum(duration)),
           perc_of_dur = round(prop_of_dur*100)) 
```


### Separate Groupings  

#### By Number of Measures   

Create basic tibble for whole work:  

```{r}
groupings_separate_tib <- gen_tib_sung %>% 
    separate(groupings, sep = "_", 
             into = c("grouping_1", "grouping_2", "grouping_3")) %>% 
    gather("grouping_1", "grouping_2", "grouping_3", key = "old_column", 
           value = "groupings") %>% 
    select(groupings) %>% 
    filter(groupings != "na") %>% 
    count(groupings) %>% 
    mutate(perc_of_groupings = (n/sum(n)*100)) 
```

Create list of 10 most common separate groupings:

```{r}
groupings_separate_10 <- groupings_separate_tib %>% 
    arrange(desc(perc_of_groupings)) %>%
    select(groupings, perc_of_groupings) %>%
    slice(1:10) 

groupings_separate_10
```


<!-- Also quite interesting!    -->

<!-- * Like `groupings_tib`, shows that **st** and **ab** are most common, though -->
<!-- interesting that **st** appears a little more frequently.   -->

<!-- * **tb** is almost as common as **none** and far more common than **sa**.   -->

<!-- ** This makes sense, since male voices sing much more than female voices.   -->


#### By Duration (of Measures)  

Create tibble with each separate grouping and its total duration:  

```{r}
groupings_separate_dur_tib <- gen_tib %>% 
    separate(groupings, sep = "_", 
             into = c("grouping_1", "grouping_2", "grouping_3")) %>% 
    gather("grouping_1", "grouping_2", "grouping_3", key = "old_column", 
           value = "groupings") %>% 
    select(groupings, duration) %>% 
    filter(groupings != "na") %>% 
    group_by(groupings) %>% 
    summarize(duration = sum(duration)) %>% 
    mutate(prop_of_dur = duration/sum(duration)) 
```

Create list of 10 most common separate groupings by duration:

```{r}
groupings_separate_10_dur <- groupings_separate_dur_tib %>% 
    arrange(desc(prop_of_dur)) %>%
    select(groupings, prop_of_dur) %>%
    slice(1:10) %>%  
    mutate(perc_of_dur = round(prop_of_dur*100))

groupings_separate_10_dur
```

Results show that factoring in duration makes *very* little difference.  











