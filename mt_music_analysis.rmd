---
title: "Formal Analysis of Hanns Eisler's music to *The Measures Taken*"
author: "Noah Zeldin"
date: "4/26/2021"
output: 
  github_document:
    toc: true
    number_sections: true
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
knitr::opts_knit$set(root.dir = "C:/Users/Noah Zeldin/Desktop/Proposal/R materials for dissertation/data/data_github")
```

# Introductory Remarks

Below is the annotated set-up for my formal analysis of Hanns Eisler's music to
*The Measures Taken*, which is included in the second chapter of my 
dissertation. This analysis was conducted in [R](https://www.r-project.org/). 
(I have tried to use [tidyverse](https://www.tidyverse.org/) syntax as 
consistently as possible. I therefore refer to tables as 
["tibbles"](https://tibble.tidyverse.org/).) Data sets will be made available to 
researchers upon request.

# Load Packages  

```{r}
library(tidyverse)
library(lubridate)
library(readxl)
```

# Importation 

There are **two** separate spreadsheets:

1. **durations** of each piece (`mt_data_durations_meters.xlsx`)

  + also used to compute e.g. rates of meter change

2. much more detailed data relating specifically to the **choral material** 
(`mt_data_choir.xlsx`)

Both are necessary. The chapter begins with a structural overview of the 
work but focuses on the choral material. However, some of the calculations 
involved with the latter require the former.

NB: Several column types in both spreadsheets must be converted to **factors** 
in a separate step because this is not an option with `readxl()` (explained 
again below).

## Duration and Meter

Import all sheets into a single list and specify column types:  

```{r}
durations_sheets <- excel_sheets("mt_data_durations_meters.xlsx")

# comments next to "col_types" are the col. names
durations_list <- 
  lapply(durations_sheets, 
         function(x) 
           read_excel("mt_data_durations_meters.xlsx",
                      sheet = x, 
                      col_types = c("text", # piece_no
                                    "numeric", # category 
                                    "text", # subcategory
                                    "numeric", # segment
                                    "numeric", # m_start
                                    "numeric", # m_end
                                    "numeric", # no_of_mm
                                    "numeric", # meter_1
                                    "numeric", # meter_2
                                    "numeric", # meter_ch_count
                                    "numeric", # quarters_per_bar
                                    "numeric", # beats
                                    "numeric", # tempo
                                    "numeric", # tempo_ch_count
                                    "numeric") # duration 
                      ))
```

From `durations_list` create single data frame and save as tibble:

```{r}
dur_tib <- as_tibble(bind_rows(durations_list))
```

## Voice Analysis

Check worksheets and ensure that there is a sheet for each piece containing 
choral material:

```{r}
excel_sheets("mt_data_choir.xlsx")
```

Import all sheets into a single list and specify column types:

```{r}
voice_analysis_sheets <- excel_sheets("mt_data_choir.xlsx")

voice_analysis_list <- 
  lapply(voice_analysis_sheets, 
         function(x) 
           read_excel("mt_data_choir.xlsx", 
                      sheet = x, 
                      col_types = c("text", # A. piece_no
                                    "numeric", # B. measure
                                    "text", # C. texture
                                    "numeric", # D. voices
                                    "text", # E. groupings
                                    "numeric", # F. soprano
                                    "numeric", # G. alto
                                    "numeric", # H. tenor
                                    "numeric", # I. bass
                                    "numeric", # J. parts_active
                                    "numeric", # K. rests_s1
                                    "numeric", # L. rests_s2
                                    "numeric", # M. rests_a1
                                    "numeric", # N. rests_a2
                                    "numeric", # O. rests_t1
                                    "numeric", # P. rests_t2
                                    "numeric", # Q. rests_b1
                                    "numeric", # R. rests_b2
                                    "numeric", # S. rests_all
                                    "numeric", # T. quarters_s1
                                    "numeric", # U. quarters_s2
                                    "numeric", # V. quarters_a1
                                    "numeric", # W. quarters_a2
                                    "numeric", # X. quarters_t1
                                    "numeric", # Y. quarters_t2
                                    "numeric", # Z. quarters_b1
                                    "numeric", # AA. quarters_b2
                                    "numeric", # AB. quarters_sum
                                    "numeric", # AC. notes_s1
                                    "numeric", # AD. notes_s2
                                    "numeric", # AE. notes_a1
                                    "numeric", # AF. notes_a2
                                    "numeric", # AG. notes_t1
                                    "numeric", # AH. notes_t2
                                    "numeric", # AI. notes_b1
                                    "numeric", # AJ. notes_b2
                                    "numeric", # AK. notes_sum
                                    "numeric", # AL. tones_s1
                                    "numeric", 
                                    "numeric", 
                                    "numeric", 
                                    "numeric", 
                                    "numeric", 
                                    "numeric", 
                                    "numeric", 
                                    "numeric", # AT. tones_sum
                                    "text", # AU. tones
                                    "numeric", # AV. spoken
                                    "numeric", # AW. acapella
                                    "numeric", # AX. meter_1
                                    "numeric", 
                                    "numeric", 
                                    "numeric", 
                                    "numeric", 
                                    "numeric", 
                                    "numeric", 
                                    "numeric", 
                                    "numeric", 
                                    "numeric", 
                                    "numeric", 
                                    "numeric", 
                                    "numeric", 
                                    "numeric", 
                                    "numeric",
                                    "numeric" 
                                    )
                      ))
```


From `voice_analysis_list` create single data frame and save as tibble:

```{r}
gen_tib <- as_tibble(bind_rows(voice_analysis_list))
```



# Cleaning and Manipulation:

## Duration and Meter

Convert **piece_no**, **category** and **subcategory** to factors (not possible 
with `readxl()`):

```{r}
dur_tib <- dur_tib %>% 
    mutate(piece_no = as_factor(piece_no)) %>% 
    mutate(category = as_factor(category)) %>% 
    mutate(subcategory = as_factor(subcategory))
```

Re-level subcategories and ensure proper order:

```{r}
dur_tib$subcategory <- dur_tib$subcategory %>% 
    fct_relevel("1b", after = 1) %>% 
    fct_relevel("2b", after = 2) %>% 
    fct_relevel("3b", after = 4) %>% 
    fct_relevel("3c", after = 5)

dur_tib$subcategory %>% 
    fct_count()
```


## Voice Analysis

### General Tibble: gen_tib

Convert **piece_no** to factor (not possible with `readxl()`):

```{r}
gen_tib <- gen_tib %>% 
    mutate(piece_no = as_factor(piece_no))
```


Since 6c now follows 7a, must re-level (and then double check):

```{r}
gen_tib$piece_no <- gen_tib$piece_no %>% 
    fct_relevel("6c", after = 7)

gen_tib$piece_no %>% 
    fct_count()
```

Group by piece:

```{r}
by_piece <- gen_tib %>% group_by(piece_no)
```

Add **rowid** column and as new first column ("id"):

```{r}
gen_tib <- gen_tib %>% 
    rowid_to_column("id")
```


### Tibble for Choral Portions: gen_tib_sung

Filter out parts without choral singing (includes passages *spoken* by choir):

```{r}
gen_tib_sung <- gen_tib %>% 
    filter(texture != "na" & 
               parts_active > 0 & 
               spoken == 0) 
```


### Tibble for Pitch: pitch_tib

Create tibble containing data on choir's pitch material in each measure:

```{r}
pitch_tib <- gen_tib_sung %>% 
    select(id, piece_no, measure, tones, dur_choir) %>%
    relocate(tones, .after = dur_choir) %>% 
    mutate(
        c = str_count(tones, "c$|c\\,"),
        c_sharp_d_flat = str_count(tones, "c-sharp|d-flat"),
        d = str_count(tones, "d$|d\\,"),
        d_sharp_e_flat = str_count(tones, "d-sharp|e-flat"),
        e = str_count(tones, "e$|e\\,"),
        f = str_count(tones, "f$|f\\,"),
        f_sharp_g_flat = str_count(tones, "f-sharp|g-flat"),
        g = str_count(tones, "g$|g\\,"),
        g_sharp_a_flat = str_count(tones, "g-sharp|a-flat"),
        a = str_count(tones, "a$|a\\,"),
        a_sharp_b_flat = str_count(tones, "a-sharp|b-flat"),
        b = str_count(tones, "b$|b\\,"),    
                ) %>% 
    rowwise %>% 
    mutate(tones_sum = sum(c_across(c:b))) 
```


# Stats

This section contains calculations derived from the tibbles generated and 
cleaned in the previous sections. These calculations formed the basis of my
formal analysis and some of the values were used in the write-up included in
the chapter.

## Durations: General

The following calculations derive from the data set: 
`mt_data_durations_meters.xlsx` (post-importation and -processing: `dur_tib`).

### Total Duration in Minutes

```{r}
dur_total_min <- sum(dur_tib$duration) / 60
```

Total duration in minutes: `r round(dur_total_min, digits = 2)`.

### Duration by Piece

Create tibble with durations for all pieces:

```{r}
dur_piece <- dur_tib %>% 
    group_by(piece_no) %>%
    summarize(duration_min = (sum(duration) / 60)) %>% 
    mutate(prop_of_dur = (duration_min/sum(duration_min)),
           duration_min = round(duration_min, digits = 2),
           prop_of_dur = round(prop_of_dur, digits = 3))

knitr::kable(dur_piece)
```


Resort to find longest pieces:

```{r}
dur_piece %>% 
  arrange(desc(duration_min)) %>% 
  mutate(perc_of_dur = prop_of_dur*100) %>% 
  select(-prop_of_dur) %>% 
  knitr::kable()
```

#### In Lubridate Format (properly displaying seconds)

Create new table with Lubridate that expresses min. and sec. properly 
(`dur_piece_lubridate`):

```{r}
# The code here is unfortunately not very elegant and must be split into 
# multiple steps.

# create foundational dataframe for further manipulation
dur_piece_lubridate <- dur_piece %>%
    as.data.frame() %>% 
    select(-prop_of_dur)

# create dummy variable for decimal values that retains trailing zeros 
# (later converted to seconds)
x <- sub("^[^.]*[.]", "", 
         format(dur_piece_lubridate$duration_min, 
                width = max(nchar(dur_piece_lubridate$duration_min))))

# split min col and prep for conversion to Lubridate format
dur_piece_lubridate <- dur_piece_lubridate %>% 
  mutate(sec = x, min = str_split(duration_min, "\\.", simplify = FALSE, n = 2), 
           .keep = "unused", .before = "sec") %>%   
  unnest_wider(min) %>% 
  rename(min = "...1") %>% 
  select(-"...2") %>% 
  mutate(min = as.numeric(min), 
           sec = as.numeric(sec)) %>%
  mutate(sec = round(sec * .6),
         duration = (minutes(min) + seconds(sec)), .keep = "unused") %>%
  relocate(duration, .after = piece_no) %>% 
  select(-sec)

# delete dummy variable
rm(x)

# view results
dur_piece_lubridate %>% 
  knitr::kable()
```


### Duration by Category

I assigned one of four categories to each of the pieces. These are:

1. choir with orchestra

2. spoken dialogue with orchestra

3. pieces featuring solo tenor

4. choir acapella or choir with snare drum


```{r}
dur_tib %>% 
  group_by(category) %>%
  summarize(duration = sum(duration)) %>% 
  mutate(perc_of_dur = round((duration/sum(duration))*100, digits = 2)) %>% 
  knitr::kable()
```


### Duration by Subcategory

Each of the four categories was then subdivided, resulting in a total of ten
different subcategories of music. (All of this is laid out in **table 2.1. The 
Structure of *The Measures Taken*** in ch. 2 of the dissertation.)

```{r}
dur_subcategory <- dur_tib %>% 
    group_by(subcategory) %>%
    summarize(duration = sum(duration)) %>% 
    mutate(duration_min = (duration/60)) %>% 
    mutate(prop_of_dur = (duration/sum(duration)))

knitr::kable(dur_subcategory)
```


## Meter and Tempo

An important feature of Eisler's music for *The Measures Taken* are the frequent
meter changes. These, along with the frequent tempo changes in a handful of 
pieces, demonstrate the necessity of a professional conductor. (The reliance
of the non-professional workers' choir on an array of professional musicians is 
an important part of my argument in the dissertation, as it contradicts much of
the previous, text-oriented scholarship on the work by Brecht scholars.) 

### Rates of Change

Construct tibble with following stats for each piece:

* duration

* number of meter changes

* rate of meter changes in seconds = duration / number of meter changes

* rate of meter changes in bars

* number of tempo changes

* rate of tempo changes in seconds = duration / number of meter changes

* rate of tempo changes in bars


```{r}
dur_meter_tempo_piece <- dur_tib %>% 
    group_by(piece_no) %>% 
    summarize(meter_ch_count = sum(meter_ch_count),
              tempo_ch_count = sum(tempo_ch_count),
              duration = sum(duration)) %>% 
    mutate(meter_ch_rate_sec = round(duration / meter_ch_count, 
                                     digits = 2),
           tempo_ch_rate_sec = round(duration / tempo_ch_count, 
                                     digits = 2),
           duration = round(duration, digits = 2)) %>% 
    relocate(meter_ch_rate_sec, .after = meter_ch_count) %>% 
    relocate(tempo_ch_rate_sec, .after = tempo_ch_count)

knitr::kable(dur_meter_tempo_piece)
```


5 pieces with greatest number of meter changes:

```{r}
meter_ch_count_piece_top_5 <- dur_meter_tempo_piece %>% 
    arrange(desc(meter_ch_count)) %>% 
    select(-tempo_ch_count, -tempo_ch_rate_sec) %>% 
    slice(1:5)

knitr::kable(meter_ch_count_piece_top_5)
```


5 pieces with fastest rates of meter change:

```{r}
meter_ch_rate_piece_top_5 <- dur_meter_tempo_piece %>% 
    filter(meter_ch_count != 1) %>% 
    select(-tempo_ch_count, -tempo_ch_rate_sec) %>% 
    arrange(meter_ch_rate_sec) %>% 
    slice(1:5)

knitr::kable(meter_ch_rate_piece_top_5)
```

3 pieces with greatest number of tempo changes:  

```{r}
tempo_ch_count_and_rate_piece <- dur_meter_tempo_piece %>% 
    filter(tempo_ch_count != 1) %>% 
    select(-meter_ch_count, -meter_ch_rate_sec) %>% 
    arrange(tempo_ch_rate_sec)

knitr::kable(tempo_ch_count_and_rate_piece)
```

### Most Common Meters

Create tibble with meter, number of meters and duration (`dur_meter`):

```{r}
dur_meter <- dur_tib %>% 
    unite(meter_1, meter_2, col = "meter", sep = "_") %>% 
    select(piece_no, no_of_mm, meter, duration) %>% 
    relocate(meter, .after = piece_no) %>% 
    filter(meter != "0_0") # remove the pick-up from piece_no 10
```

Most common meters by number of measures:

```{r}
dur_meter %>% 
  group_by(meter) %>% 
  count(no_of_mm) %>% 
  mutate(no_of_mm = no_of_mm * n) %>% 
  select(-n) %>% 
  summarize(no_of_mm = sum(no_of_mm)) %>% 
  arrange(desc(no_of_mm)) %>% 
  knitr::kable()
```

Most common meters by duration:

```{r}
dur_meter %>% 
  group_by(meter) %>% 
  summarize(duration = sum(duration)) %>% 
  mutate(duration = round(duration, digits = 2)) %>% 
  arrange(desc(duration)) %>% 
  knitr::kable()
```

#### Grouped by Duple vs. Triple

Exploring the proportion of duple vs. triple meters allows one to determine 
Eisler's engagement with march-like anthems (duple meters) and subversion 
thereof (triple meters). In short, while the music to *The Measures Taken* is
undoubtedly highly political, Eisler, in his typical manner, used musical 
materials in a critical fashion, rather than composing straightforward anthems.


```{r}
dur_meter_groups <- dur_meter %>% 
    group_by(meter) %>% 
    summarize(duration = sum(duration)) %>% 
    separate(meter, sep = "_", into = c("meter_1", "meter_2")) %>% 
    mutate(meter_1 = as.factor(meter_1))

dur_meter_groups$meter_1 <- dur_meter_groups$meter_1 %>% 
    fct_relabel(~ c("other", "duple", "triple", "duple", "duple"))

dur_meter_groups <- dur_meter_groups %>% 
    select(-meter_2) %>% 
    rename(group = meter_1) %>% 
    group_by(group) %>% 
    summarize(duration = sum(duration)) %>% 
    mutate(prop_dur = duration / sum(duration),
           perc_dur = round(prop_dur*100))

knitr::kable(dur_meter_groups)
```


#### Special Case: 6/4

6/4 is compound duple and therefore a special case. NB: 6/4 is the only compound
duple meter present in the work.

Check which measures are in 6/4:

```{r}
gen_tib %>% 
  filter(meter_1 == 6, meter_2 == 4) %>% 
  select(id:measure) %>% 
  knitr::kable()
```

Compute percent of duration that is 6/4:

```{r}
dur_6_4_perc <- round((dur_meter %>% 
    filter(meter == "6_4") %>% 
    select(duration) %>% 
    sum() / 
  dur_meter_groups %>% 
    select(duration) %>% 
    sum()) * 100, digits = 1)
```

`r dur_6_4_perc` % of the work is in 6/4.

Compute percent of duration of duple that is 6/4:

```{r}
dur_6_4_duple_perc <- round((dur_meter %>% 
    filter(meter == "6_4") %>% 
    select(duration) %>% 
    sum() / 
  dur_meter_groups %>% 
    filter(group == "duple") %>% 
    select(duration) %>% 
    sum()) * 100, digits = 1)
```

`r dur_6_4_duple_perc` % of measures with duple meters are in 6/4.


## Durations: Choir

This section is very significant to my analysis, which focuses on the choral
material. The calculations here determine the proportions of choral material 
that are sung (with and without instrumental accompaniment) or spoken.

The following calculations derive from the data set: 
`mt_data_choir.xlsx` (post-importation and -processing: `dur_choir`).

### Choir Total Durations

Create tibble containing only measures with choir:

```{r}
choir_tib <- gen_tib %>% 
    filter(dur_choir != 0)
```

Total duration of choir:

```{r}
# in seconds
dur_choir_total_sec <- sum(choir_tib$dur_choir)

# in minutes
dur_choir_total_min <- sum(choir_tib$dur_choir) / 60
```

The choir is active for `r round(dur_choir_total_min, digits = 2)` minutes.

Duration of choir as proportion of total duration:

```{r}
dur_choir_prop <- round((dur_choir_total_min / dur_total_min), digits = 4)*100
```

The choir is active for `r dur_choir_prop` % of total duration of music.


### Choir Sung Durations

Create table listing the pieces with the greatest durations of **sung** choral 
material:

```{r}
gen_tib %>% 
    filter(dur_choir != 0 & spoken == 0) %>% 
    group_by(piece_no) %>% 
    select(piece_no, dur_choir) %>% 
    summarize(dur_choir = sum(dur_choir)) %>% 
    mutate(dur_choir_prop = dur_choir / sum(dur_choir)) %>% 
    mutate(dur_choir = round(dur_choir, digits = 2), 
           dur_choir_prop = round(dur_choir_prop, digits = 3)) %>% 
    arrange(desc(dur_choir_prop)) %>% 
    knitr::kable()
```


### Choir Acapella Durations

Create list of pieces with **acapella** choral material (saved as 
`dur_acapella`):

```{r}
dur_acapella <- gen_tib %>% 
    filter(acapella == 1) %>% 
    group_by(piece_no) %>% 
    select(piece_no, dur_choir) %>% 
    summarize(dur_choir = sum(dur_choir)) %>% 
    mutate(dur_choir_prop = dur_choir / sum(dur_choir),
           dur_choir = round(dur_choir, digits = 2),
           dur_choir_prop = round(dur_choir_prop, digits = 3)) 

knitr::kable(dur_acapella)
```

Arrange `dur_acapella` by duration (descending) to see top pieces:

```{r}
dur_acapella %>% 
  arrange(desc(dur_choir_prop)) %>% 
  mutate(dur_choir_perc = dur_choir_prop*100, .keep = "unused") %>% 
  knitr::kable()
```

Proportion of `dur_chor` that is acapella:

```{r}
sum(dur_acapella$dur_choir) / dur_choir_total_sec
```




### Choir Spoken Durations

Create list of works with greatest durations of **spoken** choral material:

```{r}
gen_tib %>% 
  filter(spoken == 1) %>% 
  group_by(piece_no) %>% 
  select(piece_no, dur_choir) %>% 
  summarize(dur_choir = sum(dur_choir)) %>% 
  mutate(dur_choir_prop = dur_choir / sum(dur_choir),
         dur_choir = round(dur_choir, digits = 2),
         dur_choir_prop = round(dur_choir_prop, digits = 3)) %>% 
  arrange(desc(dur_choir_prop)) %>% 
  knitr::kable()
```


### Choir Voice Durations 

#### Check for measures where duration of 1st and 2nd parts don't align.

NB: As is typical for choral music, Eisler sometimes splits the part of one or 
more of the four voices. The calculations below account for this.

1. Sopranos

```{r}
gen_tib_sung %>% 
  filter(quarters_s1 != 0 & quarters_s2 != 0 & quarters_s1 != quarters_s2) %>% 
  nrow()
```

2. Altos

```{r}
gen_tib_sung %>% 
  filter(quarters_a1 != 0 & quarters_a2 != 0 & quarters_a1 != quarters_a2) %>% 
  nrow()
```

3. Tenors

```{r}
gen_tib_sung %>% 
  filter(quarters_t1 != 0 & quarters_t2 != 0 & quarters_t1 != quarters_t2) %>% 
  select(piece_no, measure, dur_t1, dur_t2)
```

* Only the antiphonic passage at beginning of "Lob der Partei." This doesn't 
impact any of the calculations, because even though t1 and t2 are split, they 
overlap.

4. Basses

```{r}
gen_tib_sung %>% 
  filter(quarters_b1 != 0 & quarters_b2 != 0 & quarters_b1 != quarters_b2) %>% 
  select(piece_no, measure, dur_b1, dur_b2)
```

* Only the final measure of "Streiklied." As is the case with the tenors, this 
doesn't matter, because b1 and b2 overlap.


#### Check for measures where 2nd sings but 1st doesn't

NB: Similar goal as in previous section.

1. Sopranos

```{r}
gen_tib_sung %>% 
  filter(quarters_s1 == 0 & quarters_s2 != 0) %>% 
  nrow()
```

2. Altos

```{r}
gen_tib_sung %>% 
  filter(quarters_a1 == 0 & quarters_a2 != 0) %>% 
  nrow()
```

3. Tenors

```{r}
gen_tib_sung %>% 
  filter(quarters_t1 == 0 & quarters_t2 != 0) %>% 
  select(piece_no, measure, dur_t1, dur_t2)
```

* Only the beginning of "Lob der Partei," as expected. Save as extra duration to 
add to male proportion (`dur_t2_extra`).

```{r}
dur_t2_extra <- gen_tib_sung %>% 
  filter(quarters_t1 == 0 & quarters_t2 != 0) %>%
  select(dur_t2) %>% 
  sum()
```


4. Basses

```{r}
gen_tib_sung %>% 
  filter(quarters_b1 == 0 & quarters_b2 != 0) %>% 
  nrow()
```


##### Same but with duration

1. Sopranos

```{r}
gen_tib_sung %>% 
  filter(dur_s1 != 0 & dur_s2 != 0 & dur_s1 != dur_s2) %>% 
  nrow()
```

2. Altos

```{r}
gen_tib_sung %>% 
  filter(dur_a1 != 0 & dur_a2 != 0 & dur_a1 != dur_a2) %>% 
  nrow()
```

3. Tenors

```{r}
gen_tib_sung %>% 
    filter(dur_t1 != 0 & dur_t2 != 0 & dur_t1 != dur_t2) %>% 
    select(piece_no, measure, dur_t1, dur_t2) 
```

* This doesn't matter because there is overlap.

4. Basses

```{r}
gen_tib_sung %>% 
    filter(dur_b1 != 0 & dur_b2 != 0 & dur_b1 != dur_b2) %>% 
    select(piece_no, measure, dur_b1, dur_b2)
```

* Again, this doesn't matter because of the overlap.



#### Computations for male vs. female

The introduction of mixed choirs into the German worker-singers' movement was a
widely discussed and highly politicized topic in the Weimar Republic. I 
address this point briefly in ch. 2.  

These following calculations determine the extent to which Eisler used women's
voices in comparison to men's voices.

Generate sums of sung material for each voice:

```{r}
# soprano
dur_s1_sung <- gen_tib_sung %>% 
    select(dur_s1) %>% 
    sum()

# alto
dur_a1_sung <- gen_tib_sung %>% 
    select(dur_a1) %>% 
    sum()

# tenor
dur_t1_sung <- gen_tib_sung %>% 
    select(dur_t1) %>% 
    sum()

# bass
dur_b1_sung <- gen_tib_sung %>% 
    select(dur_b1) %>% 
    sum()

# total (plus extra from tenor 2 - see above)
dur_sung_total <- dur_s1_sung + dur_a1_sung + dur_t1_sung + dur_b1_sung + 
  dur_t2_extra

# total of women's voices (soprano + alto)
dur_women_sung <- dur_s1_sung + dur_a1_sung

# total of men's voices (tenor + bass)
dur_men_sung <- dur_t1_sung + dur_b1_sung + dur_t2_extra
```

Calculate proportions of male and female durations and save for further 
calculations:

```{r}
dur_women_sung_perc <- round((dur_women_sung/dur_sung_total)*100)

dur_men_sung_perc <- round((dur_men_sung/dur_sung_total)*100)
```


Compute proportion of discrepancy resulting from pieces 5 and 7a (the two pieces 
that feature men's choir):

1. Get extra durations for tenors and basses:

```{r}
dur_t1_sung_5_and_7a <- gen_tib_sung %>% 
    filter(piece_no == "5" | piece_no == "7a") %>% 
    select(dur_t1) %>% 
    sum()

dur_b1_sung_5_and_7a <-gen_tib_sung %>% 
    filter(piece_no == "5" | piece_no == "7a") %>% 
    select(dur_b1) %>% 
    sum()
```

2. Amount by which `dur_men` is longer than `dur_women`:

```{r}
dur_men_sung - dur_women_sung
```

3. Extra duration from 5 and 7a:

```{r}
dur_t1_sung_5_and_7a + dur_b1_sung_5_and_7a
```

4. Compute percentage:

```{r}
dur_men_extra_from_5_and_7a_perc <- 
  round(((dur_t1_sung_5_and_7a + dur_b1_sung_5_and_7a) /
         (dur_men_sung - dur_women_sung)) * 100)

dur_men_extra_from_5_and_7a_perc
```


## Texture

The texture of the choral writing plays a pivotal role in my analysis. The 
calculations in this section confirm implicitly statistical observations made in
previous analyses of the work, most significantly the claim that homophony 
dominates.

Additionally, the results of the analysis here provide the foundation for my 
claim that there is a strong relationship between choral texture and textual
content. In short, Eisler tends to set texts with concrete political content to 
sparser choral textures (monophony and reduced homophony). This claim is fully
developed in ch. 2.

To be clear, **a** refers to antiphony, **h** to homophony, **m** to monophony 
and **p** to polyphony.


### Whole Work

As a precaution, I compute the proportions of each texture in relation to both 
**measure count** and **duration**. The results differ very little from each 
other.

#### By Measure Count

Generate tibble for whole work (`texture_tib_mm`):

```{r}
texture_tib_mm <- gen_tib %>% 
    count(texture) %>% 
    as_tibble %>% 
    rename(n_measures = n) %>% 
    filter(texture != "na") %>% 
    mutate(prop_of_sung = (n_measures/sum(n_measures)*100))
```


Create a basic barplot of textures for whole work (for basic exploratory 
purposes):

```{r}
texture_tib_mm %>% 
    ggplot() +
    geom_col(aes(x = texture, y = prop_of_sung, fill = texture))
```

* Homophony clearly dominates, followed by monophony.


#### By Duration

Create tibble:

```{r}
texture_tib_dur <- gen_tib %>% 
    filter(texture != "na") %>% 
    group_by(texture) %>% 
    summarize(duration = dur_choir) %>% 
    summarize(duration = sum(duration)) %>% 
    mutate(prop_of_sung = round((duration/sum(duration)), 
                                digits = 2),
           perc_of_sung = prop_of_sung*100) 
```

Create barplot:

```{r}
texture_tib_dur %>% 
    ggplot() +
    geom_col(aes(x = texture, y = prop_of_sung, fill = texture))
```

* Again, homophony clearly dominates, followed by monophony.


### Individual Pieces (By Duration)

Create tibble (`texture_piece_dur`):

```{r}
texture_piece_dur <- gen_tib %>% 
    filter(texture != "na") %>% 
    group_by(piece_no, texture) %>% 
    summarize(duration = dur_choir) %>% 
    summarize(duration = sum(duration)) %>% 
    mutate(prop_of_piece = round((duration/sum(duration)), 
                                 digits = 2)) %>% 
    group_by(piece_no) %>% 
    mutate(dur_piece = sum(duration)
           ) %>% 
    relocate(dur_piece, .after = duration) %>% 
    ungroup() %>% 
    mutate(prop_of_work = round((duration / sum(duration)), 
                                digits = 3),
           prop_piece_of_work = dur_piece/sum(dur_piece)) # check if necessary
```

Create mosaic plot, displaying proportion of each texture in each piece:

```{r}
# create new table just for this plot
dur_texture_piece_mosaic_table <- gen_tib %>% 
    filter(texture != "na") %>% 
    group_by(piece_no, texture) %>% 
    summarize(duration = dur_choir) %>% 
    summarize(duration = sum(duration)) %>% 
    mutate(prop_of_piece = duration/sum(duration)) %>% 
    group_by(piece_no) %>% 
    mutate(dur_piece = sum(duration)) %>% 
    ungroup()

# eliminate 13a for readability
dur_texture_piece_mosaic_table <- dur_texture_piece_mosaic_table %>% 
    filter(piece_no != "13a")

# code for plot
dur_texture_piece_mosaic_plot <- ggplot(dur_texture_piece_mosaic_table, 
       aes(x = piece_no, y = prop_of_piece, 
           width = dur_piece, fill = texture)) +
    geom_bar(stat = "identity", position = "fill", color = "black") +
    facet_grid(~piece_no, scales = "free_x", space = "free_x") +
    scale_fill_brewer(palette = "RdYlGn") +
    xlab("Piece Number") +
    scale_fill_discrete(name = "Texture",
                        labels = c("Antiphony", "Homophony", 
                                   "Monophony", "Polyphony")) +
    scale_y_continuous(expand = c(0,0)) + 
    theme(axis.title.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.x = element_blank(),
          strip.background = element_blank(),
          strip.text.x = element_blank(),
          panel.border = element_rect(colour = "black", fill = NA),
          panel.background = element_rect(fill = NA, color = "white")
          ) +
    labs(title = "Proportion of Choral Texture by Piece",
         subtitle = "Bar width corresponds to duration of choral material in each piece. \n13a removed for readability.")

dur_texture_piece_mosaic_plot
```

* included in ch. 2


## Pitch

Although pitch is a secondary consideration in my analysis, I wanted to get a 
sense of the chromaticism of each piece. As I point out in ch. 2, the pieces
with more concretely political texts tend to be less chromatic.

### Set-Up for Pitch Computations

Create new, elongated table with pitches:

```{r}
pitch_long <- pitch_tib %>% 
  mutate(c = c*1, # unnecessary but included for clarity
         c_sharp_d_flat = c_sharp_d_flat*2,
         d = d*3,
         d_sharp_e_flat = d_sharp_e_flat*4,
         e = e*5,
         f = f*6,
         f_sharp_g_flat = f_sharp_g_flat*7,
         g = g*8,
         g_sharp_a_flat = g_sharp_a_flat*9,
         a = a*10,
         a_sharp_b_flat = a_sharp_b_flat*11,
         b = b*12) %>% 
  pivot_longer(c:b, names_to = "pitch", values_to = "value") %>% 
  filter(value != 0) %>% 
  mutate(pitch = as.factor(pitch),
         value = as.factor(value)) %>% 
  mutate(pitch = fct_relevel(pitch,
                             levels = c("c",
                                        "c_sharp_d_flat",
                                        "d",
                                        "d_sharp_e_flat",
                                        "e",
                                        "f",
                                        "f_sharp_g_flat",
                                        "g",
                                        "g_sharp_a_flat",
                                        "a",
                                        "a_sharp_b_flat",
                                        "b")))
```

### Pitch Distribution

NB: While this chart is not included in the chapter write-up, I found it helpful 
for exploratory analysis and am therefore including it here.

```{r}
pitch_distribution_plot <- pitch_long %>% 
    group_by(piece_no) %>%
    count(pitch) %>% 
    mutate(mm = sum(n)) %>% 
    mutate(prop_piece = n / mm) %>% 
    ggplot(aes(x = pitch,
                 fill = pitch, y = prop_piece)) +
    geom_col() +
    scale_x_discrete(labels = c("C ", "C#", "D ", "D#", "E ", "F ", "F#",
                                "G ", "G#", "A ", "A#", "B " )) +
    scale_y_continuous(
        breaks = c(0.25, 0.5), labels = c("25%", "50%") 
        ) +
    ylab("Proportion of Appearances (per Measure Count)") + 
    facet_wrap(~piece_no, ncol = 7) +
    coord_flip() +
    theme(legend.position = "none", 
          axis.title.y = element_blank(),
          panel.background = element_rect(fill = "white", colour = 'black'),
          panel.grid.major.y = element_line(color = "grey", linetype = 3),
          panel.grid.major.x = element_line(color = "grey", linetype = 3),
          strip.background = element_rect(fill = "gray89", 
                                          color = "black")) +
    labs(title = "Distribution of Choir's Pitches"
         , subtitle = "Based on number of measures, in which each pitch appears."
         )

pitch_distribution_plot
```


### Chromaticism of Each Piece

Sort pieces by number of pitches that appear in choral writing.

```{r}
pitch_no_piece <- pitch_long %>% 
    group_by(piece_no) %>% 
    count(pitch) %>% 
    count(piece_no) %>% 
    rename(no_of_pitches = n) %>% 
    arrange(desc(no_of_pitches))

knitr::kable(pitch_no_piece)
```


## Groupings 

Eisler frequently grouped voices together, which relates directly to his heavy 
use of reduced choral textures (monophony and homophony). The calculations in 
this section explore this compositional tactic and determine for instance which 
groupings of voices are most common.  

NB: It is necessary to perform two separate calculations:  

1. separate groupings  

2. combinations of groupings  

To give an example of why both calculations are necessary: The first reveals the 
duration of the grouping sopranos-tenors, while the second will reveals the 
duration of this grouping *plus* the grouping altos-basses. 

### Combinations of Groupings   

#### By Number of Measures  

Generate basic tibble for whole work:

```{r}
groupings_tib <- gen_tib_sung %>% 
    count(groupings) %>% # number of measures but not durations
    as_tibble %>% 
    rename(n_groupings = n) %>% 
    filter(groupings != "na") %>% 
    mutate(prop_of_groupings = n_groupings/sum(n_groupings))
```



Create list of 5 most common groupings:

```{r}
groupings_5 <- groupings_tib %>% 
    arrange(desc(prop_of_groupings)) %>%
    select(groupings, prop_of_groupings) %>%
    slice(1:5) %>% 
    mutate(perc_of_groupings = round((prop_of_groupings*100), digits = 0)) 

groupings_5 %>% 
  select(groupings, perc_of_groupings) %>% 
  knitr::kable()
```


#### By Duration (of Measures)  

Create tibble with groupings, duration and proportion:  

```{r}
groupings_dur_tib <- gen_tib_sung %>% 
    select(groupings, duration) %>% 
    filter(groupings != "na") %>% 
    group_by(groupings) %>%
    summarize(duration = sum(duration)) %>% 
    mutate(prop_of_dur = (duration/sum(duration)))
```

Create list of 5 most common groupings by duration:

```{r}
groupings_5_dur <- groupings_dur_tib %>% 
    arrange(desc(prop_of_dur)) %>%
    select(groupings, prop_of_dur) %>%
    slice(1:5) %>%  
    mutate(perc_of_dur = round(prop_of_dur*100))

groupings_5_dur %>% 
  select(groupings, perc_of_dur) %>% 
  knitr::kable()
```

This differs only slightly from previous computation (by number of measures). 
Top 3 and no. 5 are same as `groupings_5` but 4th place is now **satb** (rather 
than **st**). 

##### Separated by Texture

```{r}
groupings_texture_dur <- gen_tib_sung %>% 
    select(groupings, texture, duration) %>% 
    filter(groupings != "na",
           texture != "na") %>% 
    group_by(groupings, texture) %>%
    summarize(duration = sum(duration)) %>% 
    mutate(prop_of_dur_text = (duration/sum(duration)),
           perc_of_dur_text = round(prop_of_dur_text*100)) %>%
    arrange(groupings, desc(duration))

groupings_texture_dur %>% 
  select(-prop_of_dur_text) %>% 
  knitr::kable()
```

With top 5 groupings:

```{r}
groupings_texture_dur_5 <- semi_join(groupings_texture_dur, groupings_5_dur)

groupings_texture_dur_5 %>% 
  select(-prop_of_dur_text) %>% 
  knitr::kable()
```

Compute percentages of each texture:

```{r}
groupings_texture_dur_5 %>% 
  group_by(texture) %>% 
  summarize(duration = sum(duration)) %>% 
  mutate(prop_dur = duration / sum(duration),
         perc_dur = round(prop_dur * 100)) %>% 
  select(-prop_dur) %>% 
  knitr::kable()
```

Just homophony:

```{r}
groupings_homophony_dur <- gen_tib_sung %>% 
    filter(texture == "h") %>% 
    select(groupings, duration) %>% 
    group_by(groupings) %>% 
    summarize(duration = sum(duration)) %>% 
    mutate(prop_of_dur = (duration/sum(duration)),
           perc_of_dur = round(prop_of_dur*100
                               # , digits = 1 # not sure how hard I can round,
                               # really only need top 3/4, so doesn't matter
                               )) %>% 
    arrange(desc(duration))

groupings_homophony_dur %>% 
  select(-prop_of_dur) %>% 
  knitr::kable()
```

Show that all instances of homophony with no groupings are just two voices 
(necessary for write-up in ch. 2):

```{r}
gen_tib_sung %>% 
  filter(texture == "h" & groupings == "none") %>% 
  select(voices, duration) %>% 
  group_by(voices) %>% 
  summarize(duration = sum(duration)) %>% 
  mutate(prop_of_dur = (duration/sum(duration))) %>% 
  knitr::kable()
```


### Separate Groupings  

#### By Number of Measures   

Create basic tibble for whole work:  

```{r}
groupings_separate_tib <- gen_tib_sung %>% 
    separate(groupings, sep = "_", 
             into = c("grouping_1", "grouping_2", "grouping_3")) %>% 
    gather("grouping_1", "grouping_2", "grouping_3", key = "old_column", 
           value = "groupings") %>% 
    select(groupings) %>% 
    filter(groupings != "na") %>% 
    count(groupings) %>% 
    mutate(perc_of_groupings = (n/sum(n)*100)) 
```

Create list of 10 most common separate groupings:

```{r}
groupings_separate_10 <- groupings_separate_tib %>% 
  arrange(desc(perc_of_groupings)) %>%
  select(groupings, perc_of_groupings) %>%
  slice(1:10) 

groupings_separate_10 %>% 
  mutate(perc_of_groupings = round(perc_of_groupings, digits = 2)) %>% 
  knitr::kable()
```


#### By Duration (of Measures)  

Create tibble with each separate grouping and its total duration:  

```{r}
groupings_separate_dur_tib <- gen_tib %>% 
  separate(groupings, sep = "_", 
           into = c("grouping_1", "grouping_2", "grouping_3")) %>% 
  gather("grouping_1", "grouping_2", "grouping_3", key = "old_column", 
         value = "groupings") %>% 
  select(groupings, duration) %>% 
  filter(groupings != "na") %>% 
  group_by(groupings) %>% 
  summarize(duration = sum(duration)) %>% 
  mutate(prop_of_dur = duration/sum(duration)) 
```

Create list of 10 most common separate groupings by duration:

```{r}
groupings_separate_10_dur <- groupings_separate_dur_tib %>% 
  arrange(desc(prop_of_dur)) %>%
  select(groupings, prop_of_dur) %>%
  slice(1:10) %>%  
  mutate(perc_of_dur = round((prop_of_dur*100), digits = 2))

groupings_separate_10_dur %>% 
  select(-prop_of_dur) %>% 
  knitr::kable()
```

Results show that factoring in duration makes *very* little difference.  











