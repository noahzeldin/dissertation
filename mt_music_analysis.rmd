---
title: "Measures Taken Formal Musical Analysis"
author: "Noah Zeldin"
date: "4/26/2021"
output: github_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
knitr::opts_knit$set(root.dir = "C:/Users/Noah Zeldin/Desktop/Proposal/R materials for dissertation/data/Massnahme_data")
```

# Load packages  

```{r}
library(tidyverse)
library(readxl)
library(ggforce)
library(scales)
library(lubridate)
library(mosaic) # may be unnecessary
```

# Importation 

## Duration

Import all sheets into a single list and specify column types.  

```{r}
durations_sheets <- excel_sheets("Massnahme_durations_meter_changes.xlsx")

durations_list <- lapply(durations_sheets, 
                         function(x) 
                             read_excel("Massnahme_durations_meter_changes.xlsx", 
                                                  sheet = x, 
                                                          col_types = c(
                                                              "text", # piece_no
                                                              "numeric", # category
                                                              "text", # subcategory
                                                              "numeric", # segment
                                                              "numeric", # m_start
                                                              "numeric", # m_end
                                                              "numeric", # no_of_mm
                                                              "numeric", # meter_1
                                                              "numeric", # meter_2
                                                              "numeric", # meter_ch_count
                                                              "numeric", # quarters_per_bar
                                                              "numeric", # beats
                                                              "numeric", # tempo
                                                              "numeric", # tempo_ch_count
                                                              "numeric") # duration
                                                          ))
```

From list create single data frame and save as tibble.

```{r}
dur_tib <- as_tibble(bind_rows(durations_list))
```

## Voice Analysis

Check worksheets and ensure that there is a sheet for each choral piece.

```{r}
excel_sheets("Massnahme_choir_voice_analysis.xlsx")
```

Import all sheets into a single list and specify column types.

```{r}
voice_analysis_sheets <- excel_sheets("Massnahme_choir_voice_analysis.xlsx")

voice_analysis_list <- lapply(voice_analysis_sheets, 
                           function(x) read_excel("Massnahme_choir_voice_analysis.xlsx", 
                                                  sheet = x, 
                                                          col_types = c(
                                                              "text", # piece_no
                                                              "numeric", # measure
                                                              "text", # texture
                                                              "numeric", # voices
                                                              "text", # groupings
                                                              
                                                              "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", # soprano:ratio
                                                              
                                                              "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", # rests
                                                              
                                                              "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", # quarters
                                                              
                                                              "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", # notes
                                                              
                                                              "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "text", "numeric", # tones
                                                              
                                                              "numeric", "numeric", # spoken, acapella
                                                              
                                                              "numeric", "numeric", "numeric", "numeric", # meter etc.
                                                              
                                                              "numeric", "numeric", "numeric", "numeric", # general dur's
                                                              
                                                              "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric" # dur's of voices
                                                              ) 
                                                              ))
```


From list create single data frame and save as tibble.

```{r}
gen_tib <- as_tibble(bind_rows(voice_analysis_list))
```



# Cleaning and Manipulation: 1. Durations

Convert **piece_no**, **category** and **subcategory** to factors.

```{r}
dur_tib <- dur_tib %>% 
    mutate(piece_no = as_factor(piece_no)) %>% 
    mutate(category = as_factor(category)) %>% 
    mutate(subcategory = as_factor(subcategory))
```

<!-- Check to see if each piece is now a factor. -->

<!-- * NB: n col. refers to # of segments -->

<!-- ```{r} -->
<!-- dur_tib$piece_no %>%  -->
<!--     fct_count() -->
<!-- ``` -->

<!-- same for category -->

<!-- ```{r} -->
<!-- dur_tib$category %>%  -->
<!--     fct_count() -->
<!-- ``` -->


Relevel subcategories.

```{r}
dur_tib$subcategory <- dur_tib$subcategory %>% 
    fct_relevel("1b", after = 1) %>% 
    fct_relevel("2b", after = 2) %>% 
    fct_relevel("3b", after = 4) %>% 
    fct_relevel("3c", after = 5)

dur_tib$subcategory %>% 
    fct_count()
```


# Cleaning and Manipulation: 2. Voice Analysis

## General Tibble: gen_tib

Convert **piece_no** to factor.

```{r}
gen_tib <- gen_tib %>% 
    mutate(piece_no = as_factor(piece_no))
```

<!-- Check to see if each piece is now a factor. -->
<!-- * **Add something about n = # of mm. - and check.** -->

<!-- ```{r} -->
<!-- gen_tib$piece_no %>%  -->
<!--     fct_count() -->
<!-- ``` -->

Since 6c now follows 7a, must relevel (and check).

```{r}
gen_tib$piece_no <- gen_tib$piece_no %>% 
    fct_relevel("6c", after = 7)

gen_tib$piece_no %>% 
    fct_count()
```

Group by piece.

```{r}
by_piece <- gen_tib %>% group_by(piece_no)
```

Add **rowid** column and make first column (called "id").

```{r}
gen_tib <- gen_tib %>% 
    rowid_to_column("id")
```


### Additional Calculations for Density

**NB: This section will in all likelihood be deleted, since it ultimately did
not figure into the final analysis.**

Translate texture to numeric value in new column:

* monophony = 1

* homophony = 1.5

* antiphony = 1.5

* polyphony = 2

```{r}
gen_tib <- gen_tib %>% 
    mutate(texture_value = case_when(texture == "na" ~ "0", 
                                   texture == "m" ~ "1", 
                                   texture == "h" ~ "1.5", 
                                   texture == "a" ~ "1.5", # added 12.26.20
                                   texture == "p" ~ "2",)) %>% 
    mutate(texture_value = as.numeric(texture_value)) %>% 
    relocate(texture_value, .after = texture)
```

Add density column for each voice.

```{r}
gen_tib <- gen_tib %>% 
    mutate(dm_s1 = (notes_s1+tones_s1)/quarters_per_bar,
                      dm_s2 = (notes_s2+tones_s2)/quarters_per_bar,
                      dm_a1 = (notes_a1+tones_a1)/quarters_per_bar,
                      dm_a2 = (notes_a2+tones_a2)/quarters_per_bar,
                      dm_t1 = (notes_t1+tones_t1)/quarters_per_bar,
                      dm_t2 = (notes_t2+tones_t2)/quarters_per_bar,
                      dm_b1 = (notes_b1+tones_b1)/quarters_per_bar,
                      dm_b2 = (notes_b2+tones_b2)/quarters_per_bar)
```

Create a **dm_sum** column from 8 individual **dm** columns.

```{r}
gen_tib <- gen_tib %>% 
    rowwise() %>% 
    mutate(dm_sum = sum(c_across(dm_s1:dm_b2)))
```

With new **dm_sum** column, create **dmc** column.

```{r}
gen_tib <- gen_tib %>% 
    rowwise() %>% 
    mutate(dmc = (dm_sum/4)*texture_value)
```

Need to reconvert gen_tib to tibble after performing `rowwise()`.

```{r}
gen_tib <- gen_tib %>% as_tibble()
```


## Tibble for Choral Portions: gen_tib_sung

Filter out parts without choral singing. (This includes passages spoken by
the choir.)
* **CHECK IF NECESSARY TO ADD** `as_tibble()` **TO END.**

```{r}
gen_tib_sung <- gen_tib %>% 
    filter(texture != "na" & 
               parts_active > 0 & 
               spoken == 0) %>% 
    as_tibble() # may not be necessary
```

<!-- Check to see if any NAs remain. The following should return an **empty**  -->
<!-- table. -->

<!-- ```{r} -->
<!-- gen_tib_sung %>%  -->
<!--     filter(is.na(dm_s1), -->
<!--            is.na(dm_s2),  -->
<!--            is.na(dm_a1), -->
<!--            is.na(dm_a2), -->
<!--            is.na(dm_t1), -->
<!--            is.na(dm_t2), -->
<!--            is.na(dm_b1), -->
<!--            is.na(dm_b2)) %>%  -->
<!--     select(id, piece_no, measure, starts_with("notes_"), starts_with("tones_"), -->
<!--            quarters_per_bar, starts_with("dm_"))  -->
<!-- ``` -->


## Tibble for Pitch: pitch_tib

```{r}
pitch_tib <- gen_tib_sung %>% 
    select(id, piece_no, measure, tones, dur_choir, dmc) %>%
    relocate(tones, .after = dmc) %>% 
    mutate(
        c = str_count(tones, "c$|c\\,"),
        c_sharp_d_flat = str_count(tones, "c-sharp|d-flat"),
        d = str_count(tones, "d$|d\\,"),
        d_sharp_e_flat = str_count(tones, "d-sharp|e-flat"),
        e = str_count(tones, "e$|e\\,"),
        f = str_count(tones, "f$|f\\,"),
        f_sharp_g_flat = str_count(tones, "f-sharp|g-flat"),
        g = str_count(tones, "g$|g\\,"),
        g_sharp_a_flat = str_count(tones, "g-sharp|a-flat"),
        a = str_count(tones, "a$|a\\,"),
        a_sharp_b_flat = str_count(tones, "a-sharp|b-flat"),
        b = str_count(tones, "b$|b\\,"),    
                ) %>% 
    rowwise %>% 
    mutate(tones_sum = sum(c_across(c:b))) 
```


# Stats

## Durations - General

### Total Duration in Minutes

```{r}
dur_total_min <- sum(dur_tib$duration) / 60
```

Total duration in minutes: `r round(dur_total_min, digits = 2)`.

### Duration by Piece

```{r}
dur_piece <- dur_tib %>% 
    group_by(piece_no) %>%
    summarize(duration_min = (sum(duration) / 60)) %>% 
    mutate(prop_of_dur = (duration_min/sum(duration_min)),
           duration_min = round(duration_min, digits = 2),
           prop_of_dur = round(prop_of_dur, digits = 3))
```

Output of `dur_piece`:

```{r, echo=FALSE}
knitr::kable(dur_piece)
```


Resort to find longest pieces.

```{r}
dur_piece %>% 
    arrange(desc(duration_min))
```

<!-- ##### NEW with Lubridate - FIX! -->

<!-- ```{r} -->
<!-- dur_piece_lubridate <- dur_piece %>%  -->
<!--     separate(duration_min, sep = "\\.", into = c("min", "sec")) %>%  -->
<!--     mutate(min = as.numeric(min), -->
<!--            sec = as.numeric(sec) # PROBLEM - removes zeros -->
<!--            ) %>%  -->
<!--     mutate(sec = round(sec * .6)) %>%  -->
<!--     mutate(duration = (minutes(min) + seconds(sec)), .keep = "unused") %>%  -->
<!--     relocate(duration, .after = piece_no) -->

<!-- dur_piece_lubridate -->
<!-- ``` -->


### Duration by Category

```{r}
dur_tib %>% 
    group_by(category) %>%
    summarize(duration = sum(duration)) %>% 
    mutate(prop_of_dur = (duration/sum(duration)))
```

<!-- No contest: two biggest categories are 1. choir with orchestra and 3. tenor solo -->
<!-- close to 95 % -->


### Duration by Subcategory

```{r}
dur_subcategory <- dur_tib %>% 
    group_by(subcategory) %>%
    summarize(duration = sum(duration)) %>% 
    mutate(duration_min = (duration/60)) %>% 
    mutate(prop_of_dur = (duration/sum(duration)))
```

Output of `dur_subcategory`:

```{r, echo=FALSE}
knitr::kable(dur_subcategory)
```

<!-- arranged descending -->

<!-- ```{r} -->
<!-- dur_subcategory %>%  -->
<!--     arrange(desc(prop_of_dur)) -->
<!-- ``` -->

<!-- Exactly what I expected:    -->
<!-- * largest proportion = 1a. mixed choir with orchestra -->
<!-- * followed by 3. tenor solo with accompaniment -->
<!-- * then 1b. = male choir with orchestra -->
<!-- ** actually, only one piece = Streiklied -->


## Meter and Tempo

### Rates of Change

Construct table with following stats for each piece:

* duration

* number of meter changes

* rate of meter changes in seconds = duration / number of meter changes

* rate of meter changes in bars

* number of tempo changes

* rate of tempo changes in seconds = duration / number of meter changes

* rate of tempo changes in bars

```{r}
dur_meter_tempo_piece <- dur_tib %>% 
    group_by(piece_no) %>% 
    summarize(meter_ch_count = sum(meter_ch_count),
              tempo_ch_count = sum(tempo_ch_count),
              duration = sum(duration)) %>% 
    mutate(meter_ch_rate_sec = round(duration / meter_ch_count, 
                                     digits = 2),
           tempo_ch_rate_sec = round(duration / tempo_ch_count, 
                                     digits = 2),
           duration = round(duration, digits = 2)) %>% 
    relocate(meter_ch_rate_sec, .after = meter_ch_count) %>% 
    relocate(tempo_ch_rate_sec, .after = tempo_ch_count)

dur_meter_tempo_piece
```

Output of `dur_meter_tempo_piece`:

```{r, echo=FALSE}
knitr::kable(dur_meter_tempo_piece)
```

<!-- sorted by **meter_ch_count**   -->

<!-- ```{r} -->
<!-- dur_meter_tempo_piece %>%  -->
<!--     arrange(desc(meter_ch_count)) %>%  -->
<!--     select(-tempo_ch_count, -tempo_ch_rate_sec) -->
<!-- ``` -->

5 pieces with greatest number of meter changes.

```{r}
meter_ch_count_piece_top_5 <- dur_meter_tempo_piece %>% 
    arrange(desc(meter_ch_count)) %>% 
    select(-tempo_ch_count, -tempo_ch_rate_sec) %>% 
    slice(1:5)

knitr::kable(meter_ch_count_piece_top_5)
```


<!-- sorted by **meter_ch_rate_sec** ASCENDING   -->

<!-- ```{r} -->
<!-- dur_meter_tempo_piece %>%  -->
<!--     filter(meter_ch_count != 1) %>%  -->
<!--     select(-tempo_ch_count, -tempo_ch_rate_sec) %>%  -->
<!--     arrange(meter_ch_rate_sec) -->
<!-- ``` -->

5 pieces with quickest rates of meter changes.

```{r}
meter_ch_rate_piece_top_5 <- dur_meter_tempo_piece %>% 
    filter(meter_ch_count != 1) %>% 
    select(-tempo_ch_count, -tempo_ch_rate_sec) %>% 
    arrange(meter_ch_rate_sec) %>% 
    slice(1:5)

knitr::kable(meter_ch_rate_piece_top_5)
```

<!-- sorted by **tempo_ch_count**   -->

<!-- ```{r} -->
<!-- dur_meter_tempo_piece %>%   -->
<!--     select(-meter_ch_count, -meter_ch_rate_sec) %>%  -->
<!--     arrange(desc(tempo_ch_count)) -->
<!-- ``` -->

3 pieces with greatest number of tempo changes.  

```{r}
tempo_ch_count_and_rate_piece <- dur_meter_tempo_piece %>% 
    filter(tempo_ch_count != 1) %>% 
    select(-meter_ch_count, -meter_ch_rate_sec) %>% 
    arrange(tempo_ch_rate_sec)

knitr::kable(tempo_ch_count_and_rate_piece)
```

### Most Common Meters

Create tibble with meter, number of meters and duration.

```{r}
dur_meter <- dur_tib %>% 
    unite(meter_1, meter_2, col = "meter", sep = "_") %>% 
    select(piece_no, no_of_mm, meter, duration) %>% 
    relocate(meter, .after = piece_no) %>% 
    filter(meter != "0_0") # remove the pick-up from piece_no 10
```

Most common meters by number of measures:

```{r}
dur_meter %>% 
    group_by(meter) %>% 
    count(no_of_mm) %>% 
    mutate(no_of_mm = no_of_mm * n) %>% 
    select(-n) %>% 
    summarize(no_of_mm = sum(no_of_mm)) %>% 
    arrange(desc(no_of_mm))
```

Most common meters by duration:

```{r}
dur_meter %>% 
    group_by(meter) %>% 
    summarize(duration = sum(duration)) %>% 
    arrange(desc(duration))
```

#### Grouped by Duple vs. Triple

```{r}
dur_meter_groups <- dur_meter %>% 
    group_by(meter) %>% 
    summarize(duration = sum(duration)) %>% 
    separate(meter, sep = "_", into = c("meter_1", "meter_2")) %>% 
    mutate(meter_1 = as.factor(meter_1))

dur_meter_groups$meter_1 <- dur_meter_groups$meter_1 %>% 
    fct_relabel(~ c("other", "duple", "triple", "duple", "duple"))

dur_meter_groups <- dur_meter_groups %>% 
    select(-meter_2) %>% 
    rename(group = meter_1) %>% 
    group_by(group) %>% 
    summarize(duration = sum(duration)) %>% 
    mutate(prop_dur = duration / sum(duration),
           perc_dur = round(prop_dur*100))

knitr::kable(dur_meter_groups)
```

<!-- Interesting: pretty evenly split. -->

#### Special Case: 6/4

**Need to account for 6/4, which is compound duple.**

Check which measures are in 6/4.

```{r}
gen_tib %>% 
  filter(meter_1 == 6, meter_2 == 4) 
```

Compute percent of duration that is 6/4:

```{r}
dur_6_4_perc <- round((dur_meter %>% 
    filter(meter == "6_4") %>% 
    select(duration) %>% 
    sum() / 
  dur_meter_groups %>% 
    select(duration) %>% 
    sum()) * 100, digits = 1)
```

`r dur_6_4_perc` % of work is in 6/4.

Compute percent of duration of duple that is 6/4:

```{r}
dur_6_4_duple_perc <- round((dur_meter %>% 
    filter(meter == "6_4") %>% 
    select(duration) %>% 
    sum() / 
  dur_meter_groups %>% 
    filter(group == "duple") %>% 
    select(duration) %>% 
    sum()) * 100, digits = 1)
```

`r dur_6_4_duple_perc` % of measures with duple meters are in 6/4.

```{r}
# duration of duple meters
dur_meter_groups %>% 
  filter(group == "duple") %>% 
  select(duration) -
  # subtract duration of 6/4 measures
  dur_meter %>% 
    filter(meter == "6_4") %>% 
    select(duration) %>% 
    sum() - 
  # subtract duration of triple meters
  dur_meter_groups %>% 
  filter(group == "triple") %>% 
  select(duration)
```

Almost even.



